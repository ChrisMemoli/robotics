<!-- HTML generated by Beej's bgconv Python script -->

<html>
<head>
<title>Beej's Guide to Network Programming Using Internet Sockets</title>
<link rel="stylesheet" href="bgnet.css" type="text/css">
</head>

<body bgcolor="#ffffff">



    <p><center><h1>Beej's Guide to Network Programming Using Internet Sockets</h1></center><p>



    
        <p><center><i><b>Brian "Beej" Hall</b></i></center></p>

        <p><center><i><a href="mailto:beej@beej.us">beej@beej.us</a></i></center></p>

    

    <!-- 
	History:

	2.3.2:		socket man page
	2.3.3:		sockaddr_in man page
	2.3.4:		bind, listen man page
	2.3.5:		connect man page
	2.3.6:		listen, perror man page
	2.3.7:		errno man page
	2.3.8:		htonl etc man page
	2.3.9:		close man page, expanded man page leader
	2.3.10:		inet_ntoa, setsockopt man pages
	2.3.11:		getpeername man page
	2.3.12:		send/sendto man pages
	2.3.13:		shutdown man pages
	2.3.14:		gethostname man pages, fix inet_aton links
	2.3.15:		fcntl man page
	2.3.16:		recv/recvfrom man page
	2.3.17:		gethostbyname/gethostbyaddr man page
	2.3.18:		changed GET / to GET / HTTP/1.0
	2.3.19:		added select() man page
	2.3.20:		added poll() man page
	2.3.21:		section on NAT and reserved networks
	2.3.22:		typo fixes in sects "man" and "privnet"
	2.3.23:		added broadcast packets section
	 -->


    <p><center>Version 2.3.23</center></p>

    <p><center>November 5, 2005</center></p>


    <p><center><small>Copyright &#xA9; 2005  Brian "Beej Jorgensen" Hall</small></center></p>


<div id="adsense">
<td align="right" valign="top"><script type="text/javascript"><!--
google_ad_client = "pub-8191228291510015";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text";
google_ad_channel ="";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_url = "008000";
google_color_text = "000000";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script></td></tr></table>
</div>

<h2>Contents</h2>
<dl>
<dt>1. <a href="#intro">Intro</a></dt>
<dd>1.1. <a href="#audience">Audience</a></dd>
<dd>1.2. <a href="#platform">Platform and Compiler</a></dd>
<dd>1.3. <a href="#homepage">Official Homepage</a></dd>
<dd>1.4. <a href="#solaris">Note for Solaris/SunOS Programmers</a></dd>
<dd>1.5. <a href="#windows">Note for Windows Programmers</a></dd>
<dd>1.6. <a href="#emailpolicy">Email Policy</a></dd>
<dd>1.7. <a href="#mirroring">Mirroring</a></dd>
<dd>1.8. <a href="#xlate">Note for Translators</a></dd>
<dd>1.9. <a href="#copyright">Copyright and Distribution</a></dd>
<p><dt>2. <a href="#theory">What is a socket?</a></dt>
<dd>2.1. <a href="#twotypes">Two Types of Internet Sockets</a></dd>
<dd>2.2. <a href="#lowlevel">Low level Nonsense and Network Theory</a></dd>
<p><dt>3. <a href="#structs"><tt>struct</tt>s and Data Handling</a></dt>
<dd>3.1. <a href="#convert">Convert the Natives!</a></dd>
<dd>3.2. <a href="#ipaddr">IP Addresses and How to Deal With Them</a></dd>
<p><dt>4. <a href="#syscalls">System Calls or Bust</a></dt>
<dd>4.1. <a href="#socket"><tt>socket()</tt>--Get the File Descriptor!</a></dd>
<dd>4.2. <a href="#bind"><tt>bind()</tt>--What port am I on?</a></dd>
<dd>4.3. <a href="#connect"><tt>connect()</tt>--Hey, you!</a></dd>
<dd>4.4. <a href="#listen"><tt>listen()</tt>--Will somebody please call
me?</a></dd>
<dd>4.5. <a href="#accept"><tt>accept()</tt>--"Thank you for calling port
3490."</a></dd>
<dd>4.6. <a href="#sendrecv"><tt>send()</tt> and <tt>recv()</tt>--Talk
to me, baby!</a></dd>
<dd>4.7. <a href="#sendtorecv"><tt>sendto()</tt> and
<tt>recvfrom()</tt>--Talk to me, DGRAM-style</a></dd>
<dd>4.8. <a href="#closedown"><tt>close()</tt> and
<tt>shutdown()</tt>--Get outta my face!</a></dd>
<dd>4.9. <a href="#getpeername"><tt>getpeername()</tt>--Who are you?</a></dd>
<dd>4.10. <a href="#gethostname"><tt>gethostname()</tt>--Who am I?</a></dd>
<dd>4.11. <a href="#dns">DNS--You say "whitehouse.gov", I say "63.161.169.137"</a></dd>
<p><dt>5. <a href="#clientserver">Client-Server Background</a></dt>
<dd>5.1. <a href="#simpleserver">A Simple Stream Server</a></dd>
<dd>5.2. <a href="#simpleclient">A Simple Stream Client</a></dd>
<dd>5.3. <a href="#datagram">Datagram Sockets</a></dd>
<p><dt>6. <a href="#advanced">Slightly Advanced Techniques</a></dt>
<dd>6.1. <a href="#blocking">Blocking</a></dd>
<dd>6.2. <a href="#select"><tt>select()</tt>--Synchronous I/O Multiplexing</a></dd>
<dd>6.3. <a href="#sendall">Handling Partial <tt>send()</tt>s</a></dd>
<dd>6.4. <a href="#sonofdataencap">Son of Data Encapsulation</a></dd>
<dd>6.5. <a href="#broadcast">Broadcast Packets--Hello, World!</a></dd>
<p><dt>7. <a href="#faq">Common Questions</a></dt>
<p><dt>8. <a href="#man">Man Pages</a></dt>
<dd>8.1. <a href="#acceptman"><tt>accept()</tt></a></dd>
<dd>8.2. <a href="#bindman"><tt>bind()</tt></a></dd>
<dd>8.3. <a href="#connectman"><tt>connect()</tt></a></dd>
<dd>8.4. <a href="#closeman"><tt>close()</tt></a></dd>
<dd>8.5. <a href="#gethostnameman"><tt>gethostname()</tt></a></dd>
<dd>8.6. <a href="#gethostbynameman"><tt>gethostbyname()</tt>, <tt>gethostbyaddr()</tt></a></dd>
<dd>8.7. <a href="#getpeernameman"><tt>getpeername()</tt></a></dd>
<dd>8.8. <a href="#errnoman"><b><tt>errno</tt></b></a></dd>
<dd>8.9. <a href="#fcntlman"><tt>fcntl()</tt></a></dd>
<dd>8.10. <a href="#htonsman"><tt>htons()</tt>, <tt>htonl()</tt>,
<tt>ntohs()</tt>, <tt>ntohl()</tt></a></dd>
<dd>8.11. <a href="#inet_ntoaman"><tt>inet_ntoa()</tt>, <tt>inet_aton()</tt></a></dd>
<dd>8.12. <a href="#listenman"><tt>listen()</tt></a></dd>
<dd>8.13. <a href="#perrorman"><tt>perror()</tt>, <tt>strerror()</tt></a></dd>
<dd>8.14. <a href="#pollman"><tt>poll()</tt></a></dd>
<dd>8.15. <a href="#recvman"><tt>recv()</tt>, <tt>recvfrom()</tt></a></dd>
<dd>8.16. <a href="#selectman"><tt>select()</tt></a></dd>
<dd>8.17. <a href="#setsockoptman"><tt>setsockopt()</tt>, <tt>getsockopt()</tt></a></dd>
<dd>8.18. <a href="#sendman"><tt>send()</tt>, <tt>sendto()</tt></a></dd>
<dd>8.19. <a href="#shutdownman"><tt>shutdown()</tt></a></dd>
<dd>8.20. <a href="#socketman"><tt>socket()</tt></a></dd>
<dd>8.21. <a href="#sockaddr_inman"><tt>struct sockaddr_in</tt>, <tt>struct in_addr</tt></a></dd>
<p><dt>9. <a href="#reference">More References</a></dt>
<dd>9.1. <a href="#books">Books</a></dd>
<dd>9.2. <a href="#webref">Web References</a></dd>
<dd>9.3. <a href="#rfcs">RFCs</a></dd>
<p></dl><p>


<!--  =======================================================  -->

<!--  Introduction  -->

<!--  =======================================================  -->



<p><br/><hr/><h2>1. <a name="intro">Intro</a></h2></p>


<p>Hey!  Socket programming got you down?  Is this stuff just a little
too difficult to figure out from the <b><tt>man</tt></b> pages?  You want to
do cool Internet programming, but you don't have time to wade through a
gob of <tt>struct</tt>s trying to figure out if you have to call
<tt>bind()</tt> before you <tt>connect()</tt>, etc., etc.</p>

<p>Well, guess what!  I've already done this nasty business, and I'm
dying to share the information with everyone!  You've come to the right
place.  This document should give the average competent C programmer the
edge s/he needs to get a grip on this networking noise.</p>

<!--  =======================================================  -->

<!--  Audience  -->

<!--  =======================================================  -->



<p><br/><h3>1.1. <a name="audience">Audience</a></h3></p>


<p>This document has been written as a tutorial, not a reference.  It is
probably at its best when read by individuals who are just starting out
with socket programming and are looking for a foothold.  It is certainly
not the <i>complete</i> guide to sockets programming, by any
means.</p>

<p>Hopefully, though, it'll be just enough for those man pages to start
making sense... <tt>:-)</tt></p>



<!--  =======================================================  -->

<!--  Platform and Compiler  -->

<!--  =======================================================  -->



<p><br/><h3>1.2. <a name="platform">Platform and Compiler</a></h3></p>


<p>The code contained within this document was compiled on a Linux PC
using Gnu's <b><tt>gcc</tt></b> compiler.  It should, however, build on just
about any platform that uses <b><tt>gcc</tt></b>.  Naturally, this doesn't
apply if you're programming for Windows--see the <a href="#windows">section on Windows programming</a>, below.</p>



<!--  =======================================================  -->

<!--  Homepage  -->

<!--  =======================================================  -->



<p><br/><h3>1.3. <a name="homepage">Official Homepage</a></h3></p>


<p>This official location of this document is
<a href="http://beej.us/guide/bgnet/">http://beej.us/guide/bgnet/</a>.</p>



<!--  =======================================================  -->

<!--  Solaris and SunOS  -->

<!--  =======================================================  -->



<p><br/><h3>1.4. <a name="solaris">Note for Solaris/SunOS Programmers</a></h3></p>


<p>When compiling for Solaris or SunOS, you need to specify some extra
command-line switches for linking in the proper libraries.  In order to
do this, simply add "<tt>-lnsl -lsocket -lresolv</tt>" to the end of the
compile command, like so:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
$ cc -o server server.c -lnsl -lsocket -lresolv
</pre>
</table></p>


<p>If you still get errors, you could try further adding a
"<tt>-lxnet</tt>" to the end of that command line.  I don't know what
that does, exactly, but some people seem to need it.</p>

<p>Another place that you might find problems is in the call to
<tt>setsockopt()</tt>.  The prototype differs from that on my Linux
box, so instead of:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int yes=1;
</pre>
</table></p>


<p>enter this:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
char yes='1';
</pre>
</table></p>


<p>As I don't have a Sun box, I haven't tested any of the above
information--it's just what people have told me through email.</p>



<!--  =======================================================  -->

<!--  Windows  -->

<!--  =======================================================  -->



<p><br/><h3>1.5. <a name="windows">Note for Windows Programmers</a></h3></p>


<p>I have a particular dislike for Windows, and encourage you to try
Linux, BSD, or Unix instead.  That being said, you can still use this
stuff under Windows.</p>

<p>First, ignore pretty much all of the system header files I mention in
here.  All you need to include is:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
#include &lt;winsock.h&gt;
</pre>
</table></p>


<p>Wait!  You also have to make a call to <tt>WSAStartup()</tt>
before doing anything else with the sockets library.  The code to do
that looks something like this:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
#include &lt;winsock.h&gt;

{
    WSADATA wsaData;   // if this doesn't work
    //WSAData wsaData; // then try this instead

    if (WSAStartup(MAKEWORD(1, 1), &amp;wsaData) != 0) {
        fprintf(stderr, "WSAStartup failed.\n");
        exit(1);
    }
</pre>
</table></p>


<p>You also have to tell your compiler to link in the Winsock library,
usually called <i><tt>wsock32.lib</tt></i> or <i><tt>winsock32.lib</tt></i> or
somesuch.  Under VC++, this can be done through the <tt>Project</tt>
menu, under <tt>Settings...</tt>.  Click the <tt>Link</tt> tab, and look
for the box titled "Object/library modules".  Add "wsock32.lib" to that
list.</p>

<p>Or so I hear.</p>

<p>Finally, you need to call <tt>WSACleanup()</tt> when you're all
through with the sockets library.  See your online help for details.</p>

<p>Once you do that, the rest of the examples in this tutorial should
generally apply, with a few exceptions.  For one thing, you can't use
<tt>close()</tt> to close a socket--you need to use
<tt>closesocket()</tt>, instead.  Also, <tt>select()</tt> only
works with socket descriptors, not file descriptors (like
<b><tt>0</tt></b> for <tt>stdin</tt>).</p>

<p>There is also a socket class that you can use, <tt>CSocket</tt>.
Check your compilers help pages for more information.</p>

<p>To get more information about Winsock, read the <a href="http://tangentsoft.net/wskfaq/">Winsock FAQ</a> and go from there.</p>

<p>Finally, I hear that Windows has no <tt>fork()</tt> system call
which is, unfortunately, used in some of my examples.  Maybe you have to
link in a POSIX library or something to get it to work, or you can use
<tt>CreateProcess()</tt> instead.  <tt>fork()</tt> takes no
arguments, and <tt>CreateProcess()</tt> takes about 48 billion
arguments.  If you're not up to that, the <tt>CreateThread()</tt> is
a little easier to digest...unfortunately a discussion about
multithreading is beyond the scope of this document.  I can only talk
about so much, you know!</p>



<!--  =======================================================  -->

<!--  Email policy  -->

<!--  =======================================================  -->



<p><br/><h3>1.6. <a name="emailpolicy">Email Policy</a></h3></p>


<p>I'm generally available to help out with email questions so feel free
to write in, but I can't guarantee a response.  I lead a pretty busy
life and there are times when I just can't answer a question you have.
When that's the case, I usually just delete the message.  It's nothing
personal; I just won't ever have the time to give the detailed answer
you require.</p>

<p>As a rule, the more complex the question, the less likely I am to
respond.  If you can narrow down your question before mailing it and be
sure to include any pertinent information (like platform, compiler,
error messages you're getting, and anything else you think might help me
troubleshoot), you're much more likely to get a response.  For more
pointers, read ESR's document, <a href="http://www.catb.org/~esr/faqs/smart-questions.html">How To Ask
Questions The Smart Way</a>.</p>

<p>If you don't get a response, hack on it some more, try to find the
answer, and if it's still elusive, then write me again with the
information you've found and hopefully it will be enough for me to help
out.</p>

<p>Now that I've badgered you about how to write and not write me, I'd
just like to let you know that I <i>fully</i> appreciate all the
praise the guide has received over the years.  It's a real morale boost,
and it gladdens me to hear that it is being used for good! <tt>:-)</tt>
Thank you!</p>



<!--  =======================================================  -->

<!--  Mirroring  -->

<!--  =======================================================  -->




<p><br/><h3>1.7. <a name="mirroring">Mirroring</a></h3></p>


<p>You are more than welcome to mirror this site, whether publically or
privately.  If you publically mirror the site and want me to link to it
from the main page, drop me a line at <tt><a href="mailto:beej@beej.us">beej@beej.us</a></tt>.</p>



<!--  =======================================================  -->

<!--  Translators  -->

<!--  =======================================================  -->




<p><br/><h3>1.8. <a name="xlate">Note for Translators</a></h3></p>


<p>If you want to translate the guide into another language, write me at
<tt><a href="mailto:beej@beej.us">beej@beej.us</a></tt> and I'll link to your translation from the
main page.</p>

<p>Feel free to add your name and email address to the translation.</p>

<p>Sorry, but due to space constraints, I cannot host the
translations myself.</p>



<!--  =======================================================  -->

<!--  Copyright  -->

<!--  =======================================================  -->



<p><br/><h3>1.9. <a name="copyright">Copyright and Distribution</a></h3></p>


<p>Beej's Guide to Network Programming is Copyright &#xA9; 2005
Brian "Beej" Hall.</p>

<p>This guide may be freely reprinted in any medium provided that its
content is not altered, it is presented in its entirety, and this
copyright notice remains intact.</p>

<p>Educators are especially encouraged to recommend or supply copies of
this guide to their students.</p>

<p>This guide may be freely translated into any language, provided the
translation is accurate, and the guide is reprinted in its entirety.
The translation may also include the name and contact information for
the translator.</p>

<p>The C source code presented in this document is hereby granted to the
public domain.</p>

<p>Contact <tt><a href="mailto:beej@beej.us">beej@beej.us</a></tt> for more information.</p>



 <!--  /Introduction  -->



<!--  =======================================================  -->

<!--  What is a socket?  -->

<!--  =======================================================  -->




<p><br/><hr/><h2>2. <a name="theory">What is a socket?</a></h2></p>


<p>You hear talk of "sockets" all the time, and perhaps you are
wondering just what they are exactly.  Well, they're this: a way to
speak to other programs using standard Unix file descriptors.</p>

<p>What?</p>

<p>Ok--you may have heard some Unix hacker state, "Jeez,
<i>everything</i> in Unix is a file!"  What that person may have
been talking about is the fact that when Unix programs do any sort of
I/O, they do it by reading or writing to a file descriptor.  A file
descriptor is simply an integer associated with an open file.  But (and
here's the catch), that file can be a network connection, a FIFO, a
pipe, a terminal, a real on-the-disk file, or just about anything else.
Everything in Unix <i>is</i> a file!  So when you want to
communicate with another program over the Internet you're gonna do it
through a file descriptor, you'd better believe it.</p>

<p>"Where do I get this file descriptor for network communication, Mr.
Smarty-Pants?" is probably the last question on your mind right now, but
I'm going to answer it anyway: You make a call to the
<tt>socket()</tt> system routine.  It returns the socket descriptor,
and you communicate through it using the specialized <tt>send()</tt>
and <tt>recv()</tt> (<b><tt><a href="http://man.linuxquestions.org/index.php?query=send&section=2&type=2">man
send</a></tt></b>, <b><tt><a href="http://man.linuxquestions.org/index.php?query=recv&section=2&type=2">man
recv</a></tt></b>) socket calls.</p>

<p>"But, hey!" you might be exclaiming right about now.  "If it's a file
descriptor, why in the name of Neptune can't I just use the normal
<tt>read()</tt> and <tt>write()</tt> calls to communicate
through the socket?"  The short answer is, "You can!"  The longer answer
is, "You can, but <tt>send()</tt> and <tt>recv()</tt> offer much
greater control over your data transmission."</p>

<p>What next?  How about this: there are all kinds of sockets.  There
are DARPA Internet addresses (Internet Sockets), path names on a local
node (Unix Sockets), CCITT X.25 addresses (X.25 Sockets that you can
safely ignore), and probably many others depending on which Unix flavor
you run.  This document deals only with the first: Internet Sockets.</p>

<!--  =======================================================  -->

<!--  Two Types of Internet Sockets  -->

<!--  =======================================================  -->




<p><br/><h3>2.1. <a name="twotypes">Two Types of Internet Sockets</a></h3></p>


<p>What's this?  There are two types of Internet sockets?  Yes.  Well,
no.  I'm lying.  There are more, but I didn't want to scare you.  I'm
only going to talk about two types here.  Except for this sentence,
where I'm going to tell you that "Raw Sockets" are also very powerful
and you should look them up.</p>

<p>All right, already.  What are the two types?  One is "Stream
Sockets"; the other is "Datagram Sockets", which may hereafter be
referred to as "<b><tt>SOCK_STREAM</tt></b>" and
"<b><tt>SOCK_DGRAM</tt></b>", respectively.  Datagram sockets are
sometimes called "connectionless sockets".  (Though they can be
<tt>connect()</tt>'d if you really want.  See <tt><a href="#connect">connect()</a></tt>, below.)</p>

<p>Stream sockets are reliable two-way connected communication streams.
If you output two items into the socket in the order "1, 2", they will
arrive in the order "1, 2" at the opposite end.  They will also be error
free.  Any errors you do encounter are figments of your own deranged
mind, and are not to be discussed here.</p>

<p>What uses stream sockets?  Well, you may have heard of the
<b><tt>telnet</tt></b> application, yes?  It uses stream sockets.  All the
characters you type need to arrive in the same order you type them,
right?  Also, web browsers use the HTTP protocol which uses stream
sockets to get pages.  Indeed, if you telnet to a web site on port 80,
and type "<tt>GET / HTTP/1.0</tt>" and hit RETURN twice, it'll dump the
HTML back at you!</p>

<p>How do stream sockets achieve this high level of data transmission
quality?  They use a protocol called "The Transmission Control
Protocol", otherwise known as "TCP" (see <a href="http://www.rfc-editor.org/rfc/rfc793.txt">RFC-793</a> for extremely detailed info
on TCP.)  TCP makes sure your data arrives sequentially and error-free.
You may have heard "TCP" before as the better half of "TCP/IP" where
"IP" stands for "Internet Protocol" (see <a href="http://www.rfc-editor.org/rfc/rfc791.txt">RFC-791</a>.)  IP deals primarily with
Internet routing and is not generally responsible for data
integrity.</p>

<p>Cool.  What about Datagram sockets?  Why are they called
connectionless?  What is the deal, here, anyway?  Why are they
unreliable?  Well, here are some facts: if you send a datagram, it may
arrive.  It may arrive out of order.  If it arrives, the data within the
packet will be error-free.</p>

<p>Datagram sockets also use IP for routing, but they don't use TCP;
they use the "User Datagram Protocol", or "UDP" (see <a href="http://www.rfc-editor.org/rfc/rfc768.txt">RFC-768</a>.)</p>

<p>Why are they connectionless?  Well, basically, it's because you don't
have to maintain an open connection as you do with stream sockets.  You
just build a packet, slap an IP header on it with destination
information, and send it out.  No connection needed.  They are generally
used for packet-by-packet transfers of information.  Sample
applications: <b><tt>tftp</tt></b>, <b><tt>bootp</tt></b>, etc.</p>

<p>"Enough!" you may scream. "How do these programs even work if
datagrams might get lost?!"  Well, my human friend, each has it's own
protocol on top of UDP.  For example, the tftp protocol says that for
each packet that gets sent, the recipient has to send back a packet that
says, "I got it!" (an "ACK" packet.)  If the sender of the original
packet gets no reply in, say, five seconds, he'll re-transmit the packet
until he finally gets an ACK.  This acknowledgment procedure is very
important when implementing <b><tt>SOCK_DGRAM</tt></b> applications.</p>



<!--  =======================================================  -->

<!--  Two Types of Internet Sockets  -->

<!--  =======================================================  -->




<p><br/><h3>2.2. <a name="lowlevel">Low level Nonsense and Network Theory</a></h3></p>


<p>Since I just mentioned layering of protocols, it's time to talk
about how networks really work, and to show some examples of how
<b><tt>SOCK_DGRAM</tt></b> packets are built.  Practically, you can
probably skip this section.  It's good background, however.</p>

<hr/>
<center>
<img src="dataencap.png" alt="None"/>

<p><b>Data Encapsulation.</b></p>
</center><hr/>


<p>Hey, kids, it's time to learn about <i><a href="#figure1">Data
Encapsulation</a></i>!  This is very very important.  It's so
important that you might just learn about it if you take the networks
course here at Chico State <tt>;-)</tt>.
Basically, it says this: a packet is born, the packet is wrapped
("encapsulated") in a header (and rarely a footer) by the first protocol
(say, the TFTP protocol), then the whole thing (TFTP header included) is
encapsulated again by the next protocol (say, UDP), then again by the
next (IP), then again by the final protocol on the hardware (physical)
layer (say, Ethernet).</p>

<p>When another computer receives the packet, the hardware strips the
Ethernet header, the kernel strips the IP and UDP headers, the TFTP
program strips the TFTP header, and it finally has the data.</p>

<p>Now I can finally talk about the infamous <i>Layered
Network Model</i>.  This Network Model describes a system of
network functionality that has many advantages over other models.  For
instance, you can write sockets programs that are exactly the same
without caring how the data is physically transmitted (serial, thin
Ethernet, AUI, whatever) because programs on lower levels deal with it
for you.  The actual network hardware and topology is transparent to the
socket programmer.</p>

<p>Without any further ado, I'll present the layers of the full-blown
model.  Remember this for network class exams:</p>

<ul>

<li><p>Application</p></li>

<li><p>Presentation</p></li>

<li><p>Session</p></li>

<li><p>Transport</p></li>

<li><p>Network</p></li>

<li><p>Data Link</p></li>

<li><p>Physical</p></li>

</ul>


<p>The Physical Layer is the hardware (serial, Ethernet, etc.).  The
Application  Layer is just about as far from the physical layer as you
can imagine--it's the place where users interact with the
network.</p>

<p>Now, this model is so general you could probably use it as an
automobile repair guide if you really wanted to.  A layered model more
consistent with Unix might be:</p>

<ul>


<li><p>Application Layer (<i>telnet, ftp,
etc.</i>)</p></li>


<li><p>Host-to-Host Transport Layer (<i>TCP,
UDP</i>)</p></li>


<li><p>Internet Layer (<i>IP and
routing</i>)</p></li>


<li><p>Network Access Layer (<i>Ethernet, ATM, or
whatever</i>)</p></li>


</ul>


<p>At this point in time, you can probably see how these layers
correspond to the encapsulation of the original data.</p>

<p>See how much work there is in building a simple packet?  Jeez!
And you have to type in the packet headers yourself using
"<b><tt>cat</tt></b>"!  Just kidding.  All you have to do for stream
sockets is <tt>send()</tt> the data out.  All you have to do
for datagram sockets is encapsulate the packet in the method of your
choosing and <tt>sendto()</tt> it out.  The kernel builds
the Transport Layer and Internet Layer on for you and the hardware does
the Network Access Layer.  Ah, modern technology.</p>

<p>So ends our brief foray into network theory.  Oh yes, I forgot to
tell you everything I wanted to say about routing: nothing!  That's
right, I'm not going to talk about it at all.  The router strips the
packet to the IP header, consults its routing table, blah blah blah.
Check out the <a href="http://www.rfc-editor.org/rfc/rfc791.txt">IP RFC</a> if you
really really care.  If you never learn about it, well, you'll
live.</p>



 <!--  /What is a socket?  -->


<!--  =======================================================  -->

<!--  structs  -->

<!--  =======================================================  -->



<p><br/><hr/><h2>3. <a name="structs"><tt>struct</tt>s and Data Handling</a></h2></p>


<p>Well, we're finally here.  It's time to talk about programming.
In this section, I'll cover various data types used by the sockets
interface, since some of them are a real bear to figure out.</p>

<p>First the easy one: a socket descriptor.  A socket descriptor is
the following type:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int
</pre>
</table></p>


<p>Just a regular <tt>int</tt>.</p>

<p>Things get weird from here, so just read through and bear with me.
Know this: there are two byte orderings: most significant byte
(sometimes called an "octet") first, or least significant byte first.
The former is called "Network Byte Order".  Some machines store their
numbers internally in Network Byte Order, some don't.  When I say
something has to be in Network Byte Order, you have to call a function
(such as <tt>htons()</tt>) to change it from "Host Byte
Order".  If I don't say "Network Byte Order", then you must leave the
value in Host Byte Order.</p>

<p>(For the curious, "Network Byte Order" is also known as "Big-Endian
Byte Order".)</p>

<p>My First Struct<super><small>TM</small></super>--<tt>struct
sockaddr</tt>.  This structure holds socket address information for
many types of sockets:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
struct sockaddr {
    unsigned short    sa_family;    // address family, AF_xxx
    char              sa_data[14];  // 14 bytes of protocol address
}; 
</pre>
</table></p>


<p><i><tt>sa_family</tt></i> can be a variety of things, but
it'll be <b><tt>AF_INET</tt></b> for everything we do in this
document.  <i><tt>sa_data</tt></i> contains a destination address
and port number for the socket.  This is rather unwieldy since you don't
want to tediously pack the address in the <i><tt>sa_data</tt></i>
by hand.</p>

<p>To deal with <tt>struct sockaddr</tt>, programmers created a
parallel structure: <tt>struct sockaddr_in</tt> ("in" for
"Internet".)</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
struct sockaddr_in {
    short int          sin_family;  // Address family
    unsigned short int sin_port;    // Port number
    struct in_addr     sin_addr;    // Internet address
    unsigned char      sin_zero[8]; // Same size as struct sockaddr
}; 
</pre>
</table></p>


<p>This structure makes it easy to reference elements of the socket
address.  Note that <i><tt>sin_zero</tt></i> (which is included
to pad the structure to the length of a <tt>struct sockaddr</tt>)
should be set to all zeros with the function
<tt>memset()</tt>.  Also, and this is the
<i>important</i> bit, a pointer to a <tt>struct
sockaddr_in</tt> can be cast to a pointer to a <tt>struct
sockaddr</tt> and vice-versa.  So even though
<tt>connect()</tt> wants a <tt>struct sockaddr*</tt>, you
can still use a <tt>struct sockaddr_in</tt> and cast it at the last
minute!  Also, notice that <i><tt>sin_family</tt></i> corresponds
to <i><tt>sa_family</tt></i> in a <tt>struct sockaddr</tt>
and should be set to "<b><tt>AF_INET</tt></b>".  Finally, the
<i><tt>sin_port</tt></i> and <i><tt>sin_addr</tt></i> must
be in <i>Network Byte Order</i>!</p>

<p>"But," you object, "how can the entire structure,
<tt>struct in_addr sin_addr</tt>, be in Network
Byte Order?"  This question requires careful examination of the
structure <tt>struct in_addr</tt>, one of the
worst unions alive:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
// Internet address (a structure for historical reasons)
struct in_addr {
    unsigned long s_addr; // that's a 32-bit long, or 4 bytes
}; 
</pre>
</table></p>


<p>Well, it <i>used</i> to be a union, but now those
days seem to be gone.  Good riddance.  So if you have declared
<i><tt>ina</tt></i> to be of type <tt>struct
sockaddr_in</tt>, then <i><tt>ina.sin_addr.s_addr</tt></i>
references the 4-byte IP address (in Network Byte Order).  Note that
even if your system still uses the God-awful union for <tt>struct
in_addr</tt>, you can still reference the 4-byte IP address in exactly
the same way as I did above (this due to
<tt>#define</tt>s.)</p>

<!--  =======================================================  -->

<!--  Convert The Natives  -->

<!--  =======================================================  -->



<p><br/><h3>3.1. <a name="convert">Convert the Natives!</a></h3></p>


<p>We've now been lead right into the next section.  There's been too
much talk about this Network to Host Byte Order conversion--now is the
time for action!</p>

<p>All righty.  There are two types that you can convert:
<tt>short</tt> (two bytes) and <tt>long</tt> (four bytes).
These functions work for the <tt>unsigned</tt> variations as well.
Say you want to convert a <tt>short</tt> from Host Byte Order to
Network Byte Order.  Start with "h" for "host", follow it with "to",
then "n" for "network", and "s" for "short": h-to-n-s, or
<tt>htons()</tt> (read: "Host to Network Short").</p>

<p>It's almost too easy...</p>

<p>You can use every combination of "n", "h", "s", and "l" you want,
not counting the really stupid ones.  For example, there is NOT a
<tt>stolh()</tt> ("Short to Long Host") function--not at this
party, anyway.  But there are:</p>

<ul>

<li><p><tt>htons()</tt> -- "Host to Network Short"</p></li>

<li><p><tt>htonl()</tt> -- "Host to Network Long"</p></li>

<li><p><tt>ntohs()</tt> -- "Network to Host Short"</p></li>

<li><p><tt>ntohl()</tt> -- "Network to Host Long"</p></li>

</ul>


<p>Now, you may think you're wising up to this.  You might think,
"What do I do if I have to change byte order on a <tt>char</tt>?"
Then you might think, "Uh, never mind."  You might also think that since
your 68000 machine already uses network byte order, you don't have to
call <tt>htonl()</tt> on your IP addresses.  You would be
right, <i>BUT</i> if you try to port to a machine that has
reverse network byte order, your program will fail.  Be portable!  This
is a Unix world!  (As much as Bill Gates would like to think otherwise.)
Remember: put your bytes in Network Byte Order before you put them on
the network.</p>

<p>A final point: why do <i><tt>sin_addr</tt></i> and
<i><tt>sin_port</tt></i> need to be in Network Byte Order in a
<tt>struct sockaddr_in</tt>, but <i><tt>sin_family</tt></i>
does not?  The answer: <i><tt>sin_addr</tt></i> and
<i><tt>sin_port</tt></i> get encapsulated in the packet at the IP
and UDP layers, respectively.  Thus, they must be in Network Byte Order.
However, the <i><tt>sin_family</tt></i> field is only used by the
kernel to determine what type of address the structure contains, so it
must be in Host Byte Order.  Also, since
<i><tt>sin_family</tt></i> does <i>not</i> get sent
out on the network, it can be in Host Byte Order.</p>



<!--  =======================================================  -->

<!--  IP Addresses  -->

<!--  =======================================================  -->



<p><br/><h3>3.2. <a name="ipaddr">IP Addresses and How to Deal With Them</a></h3></p>


<p>Fortunately for you, there are a bunch of functions  that allow
you to manipulate IP addresses.  No need to figure them out by hand and
stuff them in a <tt>long</tt> with the
<tt>&lt;&lt;</tt> operator.</p>

<p>First, let's say you have a <tt>struct sockaddr_in ina</tt>,
and you have an IP address
"<tt>10.12.110.57</tt>" that you want to store
into it.  The function you want to use,
<tt>inet_addr()</tt>, converts an IP address in
numbers-and-dots notation into an unsigned long.  The assignment can be
made as follows:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
ina.sin_addr.s_addr = inet_addr("10.12.110.57"); 
</pre>
</table></p>


<p>Notice that <tt>inet_addr()</tt> returns the address
in Network Byte Order already--you don't have to call
<tt>htonl()</tt>.  Swell!</p>

<p>Now, the above code snippet isn't very robust because there is no
error checking.  See, <tt>inet_addr()</tt> returns
<b><tt>-1</tt></b> on error.  Remember binary numbers?
<b><tt>(unsigned)-1</tt></b> just happens to correspond to the IP address
<tt>255.255.255.255</tt>!  That's the <a href="#broadcast">broadcast</a> address!  Wrongo.  Remember to do your
error checking properly.</p>

<p>Actually, there's a cleaner interface you can use instead of
<tt>inet_addr()</tt>: it's called
<tt>inet_aton()</tt> ("aton" means "ascii to network"):</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

int inet_aton(const char *cp, struct in_addr *inp); 
</pre>
</table></p>


<p>And here's a sample usage, while packing a <tt>struct
sockaddr_in</tt> (this example will make more sense to you when you
get to the sections on <a href="#bind">
<tt>bind()</tt></a> and <a href="#connect"><tt>connect()</tt></a>.)</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
struct sockaddr_in my_addr;

my_addr.sin_family = AF_INET;         // host byte order
my_addr.sin_port = htons(MYPORT);     // short, network byte order
inet_aton("10.12.110.57", &amp;(my_addr.sin_addr));
memset(&amp;(my_addr.sin_zero), '\0', 8); // zero the rest of the struct 
</pre>
</table></p>


<p><tt>inet_aton()</tt>, <i>unlike practically
every other socket-related function</i>, returns non-zero on
success, and zero on failure.  And the address is passed back in
<i><tt>inp</tt></i>.</p>

<p>Unfortunately, not all platforms implement
<tt>inet_aton()</tt> so, although its use is preferred, the
older more common <tt>inet_addr()</tt> is used in this
guide.</p>

<p>All right, now you can convert string IP addresses to their binary
representations.  What about the other way around?  What if you have a
<tt>struct in_addr</tt> and you want to print it in numbers-and-dots
notation?  In this case, you'll want to use the function
<tt>inet_ntoa()</tt> ("ntoa" means "network to ascii") like
this:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
printf("%s", inet_ntoa(ina.sin_addr)); 
</pre>
</table></p>


<p>That will print the IP address.  Note that
<tt>inet_ntoa()</tt> takes a <tt>struct in_addr</tt> as
an argument, not a <tt>long</tt>.  Also notice that it returns a
pointer to a char.  This points to a statically stored char array within
<tt>inet_ntoa()</tt> so that each time you call
<tt>inet_ntoa()</tt> it will overwrite the last IP address
you asked for.  For example:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
char *a1, *a2;

a1 = inet_ntoa(ina1.sin_addr);  // this is 192.168.4.14
a2 = inet_ntoa(ina2.sin_addr);  // this is 10.12.110.57
printf("address 1: %s\n",a1);
printf("address 2: %s\n",a2); 
</pre>
</table></p>


<p>will print:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
address 1: 10.12.110.57
address 2: 10.12.110.57 
</pre>
</table></p>


<p>If you need to save the address, <tt>strcpy()</tt> it
to your own character array.</p>

<p>That's all on this topic for now.  Later, you'll learn to convert
a string like "whitehouse.gov" into its corresponding IP address (see
<a href="#dns">DNS</a>, below.)</p>



<p><h4>3.2.1. <a name="privnet">Private (Or Disconnected) Networks</a></h4></p>


<p>Lots of places have a firewall that hides the network from the
rest of the world for their own protection.  And often times, the firewall
translates "internal" IP addresses to "external" (that everyone else in
the world knows) IP addresses using a process called <i>Network
Address Translation</i>, or NAT.</p>

<p>Are you getting nervous yet?  "Where's he going with all this weird
stuff?"</p>

<p>Well, relax and buy yourself a drink, because as a beginner, you
don't even have to worry about NAT, since it's done for you
transparently.  But I wanted to talk about the network behind the
firewall in case you started getting confused by the network numbers you
were seeing.</p>

<p>For instance, I have a firewall at home.  I have two static IP
addresses allocated to me by the DSL company, and yet I have seven
computers on the network.  How is this possible?  Two computers can't
share the same IP address, or else the data wouldn't know which one to
go to!</p>

<p>The answer is: they don't share the same IP addresses.  They are on a
private network with 24 million IP addresses allocated to it.  They are
all just for me.  Well, all for me as far as anyone else is concerned.
Here's what's happening:</p>

<p>If I log into a remote computer, it tells me I'm logged in from
64.81.52.10 (not my real IP).  But if I ask my local computer what it's
IP address is, it says 10.0.0.5.  Who is translating the IP address from
one to the other?  That's right, the firewall!  It's doing NAT!</p>

<p>10.<i>x</i>.<i>x</i>.<i>x</i> is one of a few reserved
networks that are only to be used either on fully disconnected networks,
or on networks that are behind firewalls.  The details of which private
network numbers are available for you to use are outlined in <a href="ftp://ftp.rfc-editor.org/in-notes/rfc1918.txt">RFC 1918</a>,
but some common ones you'll see are
10.<i>x</i>.<i>x</i>.<i>x</i> and
192.168.<i>x</i>.<i>x</i>, where <i>x</i> is 0-255,
generally.  Less common is 172.<i>y</i>.<i>x</i>.<i>x</i>,
where <i>y</i> goes between 16 and 31.</p>

<p>Networks behind a NATing firewall don't <i>need</i> to be on one
of these reserved networks, but they commonly are.</p>




 <!--  /structs  -->


<!--  =======================================================  -->

<!--  System Calls  -->

<!--  =======================================================  -->



<p><br/><hr/><h2>4. <a name="syscalls">System Calls or Bust</a></h2></p>


<p>This is the section where we get into the system calls that allow
you to access the network functionality of a Unix box.  When you call
one of these functions, the kernel takes over and does all the work for
you automagically.</p>

<p>The place most people get stuck around here is what order to call
these things in.  In that, the <b><tt>man</tt></b> pages are no use,
as you've probably discovered.  Well, to help with that dreadful
situation, I've tried to lay out the system calls in the following
sections in <i>exactly</i> (approximately) the same order
that you'll need to call them in your programs.</p>

<p>That, coupled with a few pieces of sample code here and there,
some milk and cookies (which I fear you will have to supply yourself),
and some raw guts and courage, and you'll be beaming data around the
Internet like the Son of Jon Postel!</p>

<!--  =======================================================  -->

<!--  socket  -->

<!--  =======================================================  -->



<p><br/><h3>4.1. <a name="socket"><tt>socket()</tt>--Get the File Descriptor!</a></h3></p>


<p>I guess I can put it off no longer--I have to talk about the
<tt>socket()</tt> system call.  Here's the breakdown:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol); 
</pre>
</table></p>


<p>But what are these arguments?  First, <i><tt>domain</tt></i> should be
set to "<b><tt>PF_INET</tt></b>".  Next, the <i><tt>type</tt></i> argument
tells the kernel what kind of socket this is: <b><tt>SOCK_STREAM</tt></b>
or <b><tt>SOCK_DGRAM</tt></b>.  Finally, just set <i><tt>protocol</tt></i>
to "<b><tt>0</tt></b>" to have <tt>socket()</tt> choose the correct
protocol based on the <i><tt>type</tt></i>.  (Notes: there are many more
<i><tt>domain</tt></i>s than I've listed.  There are many more
<i><tt>type</tt></i>s than I've listed.  See the <tt>socket()</tt>
man page.  Also, there's a "better" way to get the
<i><tt>protocol</tt></i>, but specifying <b><tt>0</tt></b> works in 99.9%
of all cases.  See the <tt>getprotobyname()</tt> man page if you're
curious.)</p>

<p><tt>socket()</tt> simply returns to you a socket descriptor that
you can use in later system calls, or <b><tt>-1</tt></b> on error.  The
global variable <i><tt>errno</tt></i> is set to the error's value (see
the <tt>perror()</tt> man page.)</p>

<p>(This <b><tt>PF_INET</tt></b> thing is a close relative of the
<b><tt>AF_INET</tt></b> that you used when initializing the
<b><tt>sin_family</tt></b> field in your <tt>struct sockaddr_in</tt>.  In
fact, they're so closely related that they actually have the same value,
and many programmers will call <tt>socket()</tt> and pass
<b><tt>AF_INET</tt></b> as the first argument instead of
<tt>PF_INET</tt>.  Now, get some milk and cookies, because it's
times for a story.  Once upon a time, a long time ago, it was thought
that maybe a address family (what the "AF" in "<b><tt>AF_INET</tt></b>"
stands for) might support several protocols that were referred to by
their protocol family (what the "PF" in "<b><tt>PF_INET</tt></b>" stands
for).  That didn't happen.  And they all lived happily ever after, The
End.  So the most correct thing to do is to use <b><tt>AF_INET</tt></b>
in your <tt>struct sockaddr_in</tt> and <b><tt>PF_INET</tt></b> in
your call to <tt>socket()</tt>.)</p>

<p>Fine, fine, fine, but what good is this socket?  The answer is
that it's really no good by itself, and you need to read on and make
more system calls for it to make any sense.</p>



<!--  =======================================================  -->

<!--  bind  -->

<!--  =======================================================  -->



<p><br/><h3>4.2. <a name="bind"><tt>bind()</tt>--What port am I on?</a></h3></p>


<p>Once you have a socket, you might have to associate that socket
with a port on your local machine.  (This is commonly done if you're
going to <tt>listen()</tt> for incoming connections on a
specific port--MUDs do this when they tell you to "telnet to x.y.z port
6969".)  The port number is used by the kernel to match an incoming
packet to a certain process's socket descriptor.  If you're going to
only be doing a <tt>connect()</tt>, this may be unnecessary.
Read it anyway, just for kicks.</p>

<p>Here is the synopsis for the <tt>bind()</tt> system
call:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int bind(int sockfd, struct sockaddr *my_addr, int addrlen); 
</pre>
</table></p>


<p><i><tt>sockfd</tt></i> is the socket file descriptor
returned by <tt>socket()</tt>.
<i><tt>my_addr</tt></i> is a pointer to a <tt>struct
sockaddr</tt> that contains information about your address, namely,
port and IP address.  <i><tt>addrlen</tt></i> can be set to
<tt>sizeof(struct sockaddr)</tt>.</p>

<p>Whew.  That's a bit to absorb in one chunk.  Let's have an
example:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

#define MYPORT 3490

main()
{
    int sockfd;
    struct sockaddr_in my_addr;

    sockfd = socket(PF_INET, SOCK_STREAM, 0); // do some error checking!

    my_addr.sin_family = AF_INET;         // host byte order
    my_addr.sin_port = htons(MYPORT);     // short, network byte order
    my_addr.sin_addr.s_addr = inet_addr("10.12.110.57");
    memset(&amp;(my_addr.sin_zero), '\0', 8); // zero the rest of the struct

    // don't forget your error checking for bind():
    bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof(struct sockaddr));
    .
    .
    . 
</pre>
</table></p>


<p>There are a few things to notice here:
<i><tt>my_addr.sin_port</tt></i> is in Network Byte Order.  So is
<i><tt>my_addr.sin_addr.s_addr</tt></i>.  Another thing to watch
out for is that the header files might differ from system to system.  To
be sure, you should check your local <b><tt>man</tt></b>
pages.</p>

<p>Lastly, on the topic of <tt>bind()</tt>, I
should mention that some of the process of getting your own IP address
and/or port can be automated:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
my_addr.sin_port = 0; // choose an unused port at random
my_addr.sin_addr.s_addr = INADDR_ANY;  // use my IP address 
</pre>
</table></p>


<p>See, by setting <i><tt>my_addr.sin_port</tt></i> to zero,
you are telling <tt>bind()</tt> to choose the port for you.
Likewise, by setting <i><tt>my_addr.sin_addr.s_addr</tt></i> to
<b><tt>INADDR_ANY</tt></b>, you are telling it to automatically
fill in the IP address of the machine the process is running on.</p>

<p>If you are into noticing little things, you might have seen that I
didn't put <b><tt>INADDR_ANY</tt></b> into Network Byte Order!
Naughty me.  However, I have inside info:
<b><tt>INADDR_ANY</tt></b> is really zero!  Zero still has zero on
bits even if you rearrange the bytes.  However, purists will point out
that there could be a parallel dimension where
<b><tt>INADDR_ANY</tt></b> is, say, 12 and that my code won't work
there.  That's ok with me:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
my_addr.sin_port = htons(0); // choose an unused port at random
my_addr.sin_addr.s_addr = htonl(INADDR_ANY);  // use my IP address 
</pre>
</table></p>


<p>Now we're so portable you probably wouldn't believe it.  I just
wanted to point that out, since most of the code you come across won't
bother running <b><tt>INADDR_ANY</tt></b> through
<tt>htonl()</tt>.</p>

<p><tt>bind()</tt> also returns <b><tt>-1</tt></b>
on error and sets <i><tt>errno</tt></i> to the error's
value.</p>

<p>Another thing to watch out for when calling
<tt>bind()</tt>: don't go underboard with your port numbers.
All ports below 1024 are RESERVED (unless you're the superuser)!  You
can have any port number above that, right up to 65535 (provided they
aren't already being used by another program.)</p>

<p>Sometimes, you might notice, you try to rerun a server and
<tt>bind()</tt> fails, claiming "Address already in use." What does
that mean?  Well, a little bit of a socket that was connected is still
hanging around in the kernel, and it's hogging the port.  You can either
wait for it to clear (a minute or so), or add code to your program
allowing it to reuse the port, like this:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int yes=1;
//char yes='1'; // Solaris people use this

// lose the pesky "Address already in use" error message
if (setsockopt(listener,SOL_SOCKET,SO_REUSEADDR,&amp;yes,sizeof(int)) == -1) {
    perror("setsockopt");
    exit(1);
} 
</pre>
</table></p>


<p>One small extra final note about <tt>bind()</tt>:
there are times when you won't absolutely have to call it.  If you are
<tt>connect()</tt>ing to a remote machine and you don't
care what your local port is (as is the case with
<b><tt>telnet</tt></b> where you only care about the remote port),
you can simply call <tt>connect()</tt>, it'll check to see
if the socket is unbound, and will <tt>bind()</tt> it to an
unused local port if necessary.</p>



<!--  =======================================================  -->

<!--  connect  -->

<!--  =======================================================  -->



<p><br/><h3>4.3. <a name="connect"><tt>connect()</tt>--Hey, you!</a></h3></p>


<p>Let's just pretend for a few minutes that you're a telnet
application.  Your user commands you (just like in the movie
<i>TRON</i>) to get a socket file descriptor.  You comply
and call <tt>socket()</tt>.  Next, the user
tells you to connect to "<tt>10.12.110.57</tt>"
on port "<tt>23</tt>" (the standard telnet
port.)  Yow!  What do you do now?</p>

<p>Lucky for you, program, you're now perusing the section on
<tt>connect()</tt>--how to connect to a remote host.  So
read furiously onward!  No time to lose!</p>

<p>The <tt>connect()</tt> call is as follows:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int connect(int sockfd, struct sockaddr *serv_addr, int addrlen); 
</pre>
</table></p>


<p><i><tt>sockfd</tt></i> is our friendly neighborhood socket
file descriptor, as returned by the <tt>socket()</tt> call,
<i><tt>serv_addr</tt></i> is a <tt>struct sockaddr</tt>
containing the destination port and IP address, and
<i><tt>addrlen</tt></i> can be set to
<tt>sizeof(struct sockaddr)</tt>.</p>

<p>Isn't this starting to make more sense?  Let's have an
example:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

#define DEST_IP   "10.12.110.57"
#define DEST_PORT 23

main()
{
    int sockfd;
    struct sockaddr_in dest_addr;   // will hold the destination addr

    sockfd = socket(PF_INET, SOCK_STREAM, 0); // do some error checking!

    dest_addr.sin_family = AF_INET;          // host byte order
    dest_addr.sin_port = htons(DEST_PORT);   // short, network byte order
    dest_addr.sin_addr.s_addr = inet_addr(DEST_IP);
    memset(&amp;(dest_addr.sin_zero), '\0', 8);  // zero the rest of the struct

    // don't forget to error check the connect()!
    connect(sockfd, (struct sockaddr *)&amp;dest_addr, sizeof(struct sockaddr));
    .
    .
    . 
</pre>
</table></p>


<p>Again, be sure to check the return value from
<tt>connect()</tt>--it'll return <b><tt>-1</tt></b> on
error and set the variable <i><tt>errno</tt></i>.</p>

<p>Also, notice that we didn't call <tt>bind()</tt>.
Basically, we don't care about our local port number; we only care where
we're going (the remote port).  The kernel will choose a local port for
us, and the site we connect to will automatically get this information
from us.  No worries.</p>



<!--  =======================================================  -->

<!--  listen  -->

<!--  =======================================================  -->



<p><br/><h3>4.4. <a name="listen"><tt>listen()</tt>--Will somebody please call
me?</a></h3></p>


<p>Ok, time for a change of pace.  What if you don't want to connect
to a remote host.  Say, just for kicks, that you want to wait for
incoming connections and handle them in some way.  The process is two
step: first you <tt>listen()</tt>, then you
<tt>accept()</tt> (see below.)</p>

<p>The listen call is fairly simple, but requires a bit of
explanation:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int listen(int sockfd, int backlog); 
</pre>
</table></p>


<p><i><tt>sockfd</tt></i> is the usual socket file descriptor
from the <tt>socket()</tt> system call.
<i><tt>backlog</tt></i> is the number of connections allowed on
the incoming queue.  What does that mean?  Well, incoming connections
are going to wait in this queue until you <tt>accept()</tt>
them (see below) and this is the limit on how many can queue up.  Most
systems silently limit this number to about 20; you can probably get
away with setting it to <b><tt>5</tt></b> or
<b><tt>10</tt></b>.</p>

<p>Again, as per usual, <tt>listen()</tt> returns
<b><tt>-1</tt></b> and sets <i><tt>errno</tt></i> on
error.</p>

<p>Well, as you can probably imagine, we need to call
<tt>bind()</tt> before we call <tt>listen()</tt>
or the kernel will have us listening on a random port.  Bleah!  So if
you're going to be listening for incoming connections, the sequence of
system calls you'll make is:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
socket();
bind();
listen();
/* accept() goes here */ 
</pre>
</table></p>


<p>I'll just leave that in the place of sample code, since it's
fairly self-explanatory.  (The code in the <tt>accept()</tt>
section, below, is more complete.)  The really tricky part of this whole
sha-bang is the call to <tt>accept()</tt>.</p>



<!--  =======================================================  -->

<!--  accept  -->

<!--  =======================================================  -->



<p><br/><h3>4.5. <a name="accept"><tt>accept()</tt>--"Thank you for calling port
3490."</a></h3></p>


<p>Get ready--the <tt>accept()</tt> call is kinda weird!
What's going to happen is this: someone far far away will try to
<tt>connect()</tt> to your machine on a port that you are
<tt>listen()</tt>ing on.  Their connection will be queued
up waiting to be <tt>accept()</tt>ed.  You call
<tt>accept()</tt> and you tell it to get the pending
connection.  It'll return to you a <i>brand new socket file
descriptor</i> to use for this single connection!  That's right,
suddenly you have <i>two socket file descriptors</i> for
the price of one!  The original one is still listening on your port and
the newly created one is finally ready to <tt>send()</tt>
and <tt>recv()</tt>.  We're there! </p>

<p>The call is as follows:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 
</pre>
</table></p>


<p><i><tt>sockfd</tt></i> is the
<tt>listen()</tt>ing socket descriptor.  Easy enough.
<i><tt>addr</tt></i> will usually be a pointer to a local
<tt>struct sockaddr_in</tt>.  This is where the information about
the incoming connection will go (and with it you can determine which
host is calling you from which port).  <i><tt>addrlen</tt></i> is
a local integer variable that should be set to
<tt>sizeof(struct sockaddr_in)</tt> before its
address is passed to <tt>accept()</tt>.  Accept will not put
more than that many bytes into <i><tt>addr</tt></i>. If it puts
fewer in, it'll change the value of <i><tt>addrlen</tt></i> to
reflect that.</p>

<p>Guess what?  <tt>accept()</tt> returns
<b><tt>-1</tt></b> and sets <i><tt>errno</tt></i> if an
error occurs.  Betcha didn't figure that.</p>

<p>Like before, this is a bunch to absorb in one chunk, so here's a
sample code fragment for your perusal:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

#define MYPORT 3490    // the port users will be connecting to

#define BACKLOG 10     // how many pending connections queue will hold

main()
{
    int sockfd, new_fd;  // listen on sock_fd, new connection on new_fd
    struct sockaddr_in my_addr;    // my address information
    struct sockaddr_in their_addr; // connector's address information
    int sin_size;

    sockfd = socket(PF_INET, SOCK_STREAM, 0); // do some error checking!

    my_addr.sin_family = AF_INET;         // host byte order
    my_addr.sin_port = htons(MYPORT);     // short, network byte order
    my_addr.sin_addr.s_addr = INADDR_ANY; // auto-fill with my IP
    memset(&amp;(my_addr.sin_zero), '\0', 8); // zero the rest of the struct

    // don't forget your error checking for these calls:
    bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof(struct sockaddr));

    listen(sockfd, BACKLOG);

    sin_size = sizeof(struct sockaddr_in);
    new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;sin_size);
    .
    .
    . 
</pre>
</table></p>


<p>Again, note that we will use the socket descriptor
<i><tt>new_fd</tt></i> for all <tt>send()</tt> and
<tt>recv()</tt> calls.  If you're only getting one single
connection ever, you can <tt>close()</tt> the listening
<i><tt>sockfd</tt></i> in order to prevent more incoming
connections on the same port, if you so desire.</p>



<!--  =======================================================  -->

<!--  sendrecv  -->

<!--  =======================================================  -->



<p><br/><h3>4.6. <a name="sendrecv"><tt>send()</tt> and <tt>recv()</tt>--Talk
to me, baby!</a></h3></p>


<p>These two functions are for communicating over stream sockets or
connected datagram sockets.  If you want to use regular unconnected
datagram sockets, you'll need to see the section on <a href="#sendtorecv"><tt>sendto()</tt> and
<tt>recvfrom()</tt></a>, below.</p>

<p>The <tt>send()</tt> call:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int send(int sockfd, const void *msg, int len, int flags); 
</pre>
</table></p>


<p><i><tt>sockfd</tt></i> is the socket descriptor you want to
send data to (whether it's the one returned by
<tt>socket()</tt> or the one you got with
<tt>accept()</tt>.) <i><tt>msg</tt></i> is a pointer
to the data you want to send, and <i><tt>len</tt></i> is the
length of that data in bytes.  Just set <i><tt>flags</tt></i> to
<b><tt>0</tt></b>.  (See the <tt>send()</tt> man page
for more information concerning flags.)</p>

<p>Some sample code might be:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
char *msg = "Beej was here!";
int len, bytes_sent;
.
.
.
len = strlen(msg);
bytes_sent = send(sockfd, msg, len, 0);
.
.
. 
</pre>
</table></p>


<p><tt>send()</tt> returns the number of bytes actually
sent out--<i>this might be less than the number you told it to
send!</i>  See, sometimes you tell it to send a whole gob of data
and it just can't handle it.  It'll fire off as much of the data as it
can, and trust you to send the rest later.  Remember, if the value
returned by <tt>send()</tt> doesn't match the value in
<i><tt>len</tt></i>, it's up to you to send the rest of the
string.  The good news is this: if the packet is small (less than 1K or
so) it will <i>probably</i> manage to send the whole thing
all in one go.  Again, <b><tt>-1</tt></b> is returned on error, and
<i><tt>errno</tt></i> is set to the error number.</p>

<p>The <tt>recv()</tt> call is similar in many
respects:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int recv(int sockfd, void *buf, int len, unsigned int flags); 
</pre>
</table></p>


<p><i><tt>sockfd</tt></i> is the socket descriptor to read
from, <i><tt>buf</tt></i> is the buffer to read the information
into, <i><tt>len</tt></i> is the maximum length of the buffer,
and <i><tt>flags</tt></i> can again be set to
<b><tt>0</tt></b>.  (See the <tt>recv()</tt> man page
for flag information.)</p>

<p><tt>recv()</tt> returns the number of bytes actually
read into the buffer, or <b><tt>-1</tt></b> on error (with
<i><tt>errno</tt></i> set, accordingly.)</p>

<p>Wait!  <tt>recv()</tt> can return
<b><tt>0</tt></b>.  This can mean only one thing: the remote side
has closed the connection on you!  A return value of
<b><tt>0</tt></b> is <tt>recv()</tt>'s way of letting
you know this has occurred.</p>

<p>There, that was easy, wasn't it?  You can now pass data back and
forth on stream sockets!  Whee!  You're a Unix Network
Programmer!</p>



<!--  =======================================================  -->

<!--  sendtorecv  -->

<!--  =======================================================  -->



<p><br/><h3>4.7. <a name="sendtorecv"><tt>sendto()</tt> and
<tt>recvfrom()</tt>--Talk to me, DGRAM-style</a></h3></p>


<p>"This is all fine and dandy," I hear you saying, "but where does
this leave me with unconnected datagram sockets?"  No problemo, amigo.
We have just the thing.</p>

<p>Since datagram sockets aren't connected to a remote host, guess which
piece of information we need to give before we send a packet?  That's
right!  The destination address!  Here's the scoop:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int sendto(int sockfd, const void *msg, int len, unsigned int flags,
           const struct sockaddr *to, socklen_t tolen); 
</pre>
</table></p>


<p>As you can see, this call is basically the same as the call to
<tt>send()</tt> with the addition of two other pieces of
information.  <i><tt>to</tt></i> is a pointer to a <tt>struct
sockaddr</tt> (which you'll probably have as a <tt>struct
sockaddr_in</tt> and cast it at the last minute) which contains the
destination IP address and port.  <i><tt>tolen</tt></i>, an
<tt>int</tt> deep-down, can simply be set to <tt>sizeof(struct
sockaddr)</tt>.</p>

<p>Just like with <tt>send()</tt>,
<tt>sendto()</tt> returns the number of bytes actually sent
(which, again, might be less than the number of bytes you told it to
send!), or <b><tt>-1</tt></b> on error.</p>

<p>Equally similar are <tt>recv()</tt> and
<tt>recvfrom()</tt>.  The synopsis of
<tt>recvfrom()</tt> is:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int recvfrom(int sockfd, void *buf, int len, unsigned int flags,
             struct sockaddr *from, int *fromlen); 
</pre>
</table></p>


<p>Again, this is just like <tt>recv()</tt> with the
addition of a couple fields.  <i><tt>from</tt></i> is a pointer
to a local <tt>struct sockaddr</tt> that will be filled with the IP
address and port of the originating machine.
<i><tt>fromlen</tt></i> is a pointer to a local <tt>int</tt>
that should be initialized to <tt>sizeof(struct sockaddr)</tt>.
When the function returns, <i><tt>fromlen</tt></i> will contain
the length of the address actually stored in
<i><tt>from</tt></i>.</p>

<p><tt>recvfrom()</tt> returns the number of bytes
received, or <b><tt>-1</tt></b> on error (with
<i><tt>errno</tt></i> set accordingly.)</p>

<p>Remember, if you <tt>connect()</tt> a datagram socket,
you can then simply use <tt>send()</tt> and
<tt>recv()</tt> for all your transactions.  The socket
itself is still a datagram socket and the packets still use UDP, but the
socket interface will automatically add the destination and source
information for you.</p>



<!--  =======================================================  -->

<!--  closedown  -->

<!--  =======================================================  -->





<p><br/><h3>4.8. <a name="closedown"><tt>close()</tt> and
<tt>shutdown()</tt>--Get outta my face!</a></h3></p>


<p>Whew!  You've been <tt>send()</tt>ing and
<tt>recv()</tt>ing data all day long, and you've had it.
You're ready to close the connection on your socket descriptor.  This is
easy.  You can just use the regular Unix file descriptor
<tt>close()</tt> function:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
close(sockfd); 
</pre>
</table></p>


<p>This will prevent any more reads and writes to the socket.  Anyone
attempting to read or write the socket on the remote end will receive an
error.</p>

<p>Just in case you want a little more control over how the socket
closes, you can use the <tt>shutdown()</tt> function.  It
allows you to cut off communication in a certain direction, or both ways
(just like <tt>close()</tt> does.)  Synopsis:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int shutdown(int sockfd, int how); 
</pre>
</table></p>


<p><i><tt>sockfd</tt></i> is the socket file descriptor you
want to shutdown, and <i><tt>how</tt></i> is one of the
following:</p>

<ul>


<li><b><tt>0</tt></b> -- Further receives are
disallowed</li>


<li><b><tt>1</tt></b> -- Further sends are
disallowed</li>


<li><b><tt>2</tt></b> -- Further sends and receives are
disallowed (like <tt>close()</tt>)</li>


</ul>


<p><tt>shutdown()</tt> returns <b><tt>0</tt></b> on
success, and <b><tt>-1</tt></b> on error (with
<i><tt>errno</tt></i> set accordingly.)</p>

<p>If you deign to use <tt>shutdown()</tt> on unconnected
datagram sockets, it will simply make the socket unavailable for further
<tt>send()</tt> and <tt>recv()</tt> calls
(remember that you can use these if you <tt>connect()</tt>
your datagram socket.)</p>

<p>It's important to note that <tt>shutdown()</tt>
doesn't actually close the file descriptor--it just changes its
usability.  To free a socket descriptor, you need to use
<tt>close()</tt>.</p>

<p>Nothing to it.</p>



<!--  =======================================================  -->

<!--  getpeername  -->

<!--  =======================================================  -->




<p><br/><h3>4.9. <a name="getpeername"><tt>getpeername()</tt>--Who are you?</a></h3></p>


<p>This function is so easy.</p>

<p>It's so easy, I almost didn't give it it's own section.  But here
it is anyway.</p>

<p>The function <tt>getpeername()</tt> will tell you who is at the other end
of a connected stream socket.  The synopsis:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
#include &lt;sys/socket.h&gt;

int getpeername(int sockfd, struct sockaddr *addr, int *addrlen); 
</pre>
</table></p>


<p><i><tt>sockfd</tt></i> is the descriptor of the connected
stream socket, <i><tt>addr</tt></i> is a pointer to a
<tt>struct sockaddr</tt> (or a <tt>struct sockaddr_in</tt>) that
will hold the information about the other side of the connection, and
<i><tt>addrlen</tt></i> is a pointer to an <tt>int</tt>, that
should be initialized to <tt>sizeof(struct
sockaddr)</tt>.</p>

<p>The function returns <b><tt>-1</tt></b> on error and sets
<i><tt>errno</tt></i> accordingly.</p>

<p>Once you have their address, you can use
<tt>inet_ntoa()</tt> or <tt>gethostbyaddr()</tt>
to print or get more information.  No, you can't get their login name.
(Ok, ok.  If the other computer is running an ident daemon, this is
possible.  This, however, is beyond the scope of this document.  Check
out <a href="http://www.rfc-editor.org/rfc/rfc1413.txt">RFC-1413</a> for more
info.)</p>



<!--  =======================================================  -->

<!--  gethostname  -->

<!--  =======================================================  -->




<p><br/><h3>4.10. <a name="gethostname"><tt>gethostname()</tt>--Who am I?</a></h3></p>


<p>Even easier than <tt>getpeername()</tt> is the
function <tt>gethostname()</tt>.  It returns the name of the
computer that your program is running on.  The name can then be used by
<tt>gethostbyname()</tt>, below, to determine the IP address
of your local machine.</p>

<p>What could be more fun?  I could think of a few things, but they
don't pertain to socket programming.  Anyway, here's the
breakdown:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
#include &lt;unistd.h&gt;

int gethostname(char *hostname, size_t size); 
</pre>
</table></p>


<p>The arguments are simple: <i><tt>hostname</tt></i> is a
pointer to an array of chars that will contain the hostname upon the
function's return, and <i><tt>size</tt></i> is the length in
bytes of the <i><tt>hostname</tt></i> array.</p>

<p>The function returns <b><tt>0</tt></b> on successful
completion, and <b><tt>-1</tt></b> on error, setting
<i><tt>errno</tt></i> as usual.</p>



<!--  =======================================================  -->

<!--  dns  -->

<!--  =======================================================  -->




<p><br/><h3>4.11. <a name="dns">DNS--You say "whitehouse.gov", I say "63.161.169.137"</a></h3></p>


<p>In case you don't know what DNS is, it stands for "Domain Name
Service".  In a nutshell, you tell it what the human-readable address is
for a site, and it'll give you the IP address (so you can use it with
<tt>bind()</tt>, <tt>connect()</tt>,
<tt>sendto()</tt>, or whatever you need it for.)  This way,
when someone enters:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
$ telnet whitehouse.gov
</pre>
</table></p>


<p><b><tt>telnet</tt></b> can find out that it needs to
<tt>connect()</tt> to "63.161.169.137".</p>

<p>But how does it work?  You'll be using the function
<tt>gethostbyname()</tt>:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
#include &lt;netdb.h&gt;

struct hostent *gethostbyname(const char *name); 
</pre>
</table></p>


<p>As you see, it returns a pointer to a <tt>struct hostent</tt>,
the layout of which is as follows:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
struct hostent {
    char    *h_name;
    char    **h_aliases;
    int     h_addrtype;
    int     h_length;
    char    **h_addr_list;
};
#define h_addr h_addr_list[0] 
</pre>
</table></p>


<p>And here are the descriptions of the fields in the <tt>struct
hostent</tt>:</p>

<ul>

<li><i><tt>h_name</tt></i> -- Official name of the
host.</li>


<li><i><tt>h_aliases</tt></i> -- A NULL-terminated
array of alternate names for the host.</li>


<li><i><tt>h_addrtype</tt></i> -- The type of address
being returned; usually
<i><tt>AF_INET</tt></i>.</li>


<li><i><tt>h_length</tt></i> -- The length of the
address in bytes.</li>


<li><i><tt>h_addr_list</tt></i> -- A zero-terminated
array of network addresses for the host.  Host addresses are in Network
Byte Order.</li>


<li><i><tt>h_addr</tt></i> -- The first address in
<i><tt>h_addr_list</tt></i>.</li>


</ul>


<p><tt>gethostbyname()</tt> returns a pointer to the
filled <tt>struct hostent</tt>, or NULL on error.  (But
<i><tt>errno</tt></i> is <i>not</i>
set--<i><i><tt>h_errno</tt></i></i> is set instead.
See <tt>herror()</tt>, below.)</p>

<p>But how is it used?  Sometimes (as we find from reading computer
manuals), just spewing the information at the reader is not enough.
This function is certainly easier to use than it looks.</p>

<p><a href="http://beej.us/guide/bgnet/examples/getip.c">Here's an example
program</a>:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
/*
** getip.c -- a hostname lookup demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

int main(int argc, char *argv[])
{
    struct hostent *h;

    if (argc != 2) {  // error check the command line
        fprintf(stderr,"usage: getip address\n");
        exit(1);
    }

    if ((h=gethostbyname(argv[1])) == NULL) {  // get the host info
        herror("gethostbyname");
        exit(1);
    }

    printf("Host name  : %s\n", h-&gt;h_name);
    printf("IP Address : %s\n", inet_ntoa(*((struct in_addr *)h-&gt;h_addr)));
   
   return 0;
} 
</pre>
</table></p>


<p>With <tt>gethostbyname()</tt>, you can't use
<tt>perror()</tt> to print error message (since
<i><tt>errno</tt></i> is not used).  Instead, call
<tt>herror()</tt>.</p>

<p>It's pretty straightforward.  You simply pass the string that
contains the machine name ("whitehouse.gov") to
<tt>gethostbyname()</tt>, and then grab the information out
of the returned <tt>struct hostent</tt>.</p>

<p>The only possible weirdness might be in the printing of the IP
address, above.  <i><tt>h-&gt;h_addr</tt></i> is a
<tt>char*</tt>, but <tt>inet_ntoa()</tt> wants a
<tt>struct in_addr</tt> passed to it.  So I cast
<i><tt>h-&gt;h_addr</tt></i> to a <tt>struct in_addr*</tt>,
then dereference it to get at the data.</p>



  <!--  syscalls  -->


<!--  =======================================================  -->

<!--  clientserver  -->

<!--  =======================================================  -->




<p><br/><hr/><h2>5. <a name="clientserver">Client-Server Background</a></h2></p>


<p>It's a client-server world, baby.  Just about everything on the
network deals with client processes talking to server processes and
vice-versa.  Take <b><tt>telnet</tt></b>, for instance.  When you
connect to a remote host on port 23 with telnet (the client), a program
on that host (called <b><tt>telnetd</tt></b>, the server) springs to
life.  It handles the incoming telnet connection, sets you up with a
login prompt, etc.</p>

<hr/>
<center>
    <img src="cs.png" alt="None"/>

    <p><b>Client-Server Interaction.</b></p>
</center><hr/>


<p>The exchange of information between client and server is
summarized in <a href="#figure2">Figure 2</a>.</p>

<p>Note that the client-server pair can speak
<b><tt>SOCK_STREAM</tt></b>, <b><tt>SOCK_DGRAM</tt></b>, or
anything else (as long as they're speaking the same thing.)  Some good
examples of client-server pairs are
<b><tt>telnet</tt></b>/<b><tt>telnetd</tt></b>,
<b><tt>ftp</tt></b>/<b><tt>ftpd</tt></b>, or
<b><tt>bootp</tt></b>/<b><tt>bootpd</tt></b>.  Every time you use
<b><tt>ftp</tt></b>, there's a remote program,
<b><tt>ftpd</tt></b>, that serves you.</p>

<p>Often, there will only be one server on a machine, and that server
will handle multiple clients using <tt>fork()</tt>.  The
basic routine is: server will wait for a connection,
<tt>accept()</tt> it, and <tt>fork()</tt> a
child process to handle it.  This is what our sample server does in the
next section.</p>

<!--  =======================================================  -->

<!--  simpleserver  -->

<!--  =======================================================  -->




<p><br/><h3>5.1. <a name="simpleserver">A Simple Stream Server</a></h3></p>


<p>All this server does is send the string "<tt>Hello,
World!\n</tt>" out over a stream connection.  All you need
to do to test this server is run it in one window, and telnet to it from
another with:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
$ telnet remotehostname 3490
</pre>
</table></p>


<p>where <tt>remotehostname</tt> is the name
of the machine you're running it on.</p>

<p><a href="http://beej.us/guide/bgnet/examples/server.c">The server code</a>: (Note: a
trailing backslash on a line means that the line is continued on the
next.)</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
/*
** server.c -- a stream socket server demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;signal.h&gt;

#define MYPORT 3490    // the port users will be connecting to

#define BACKLOG 10     // how many pending connections queue will hold

void sigchld_handler(int s)
{
    while(waitpid(-1, NULL, WNOHANG) &gt; 0);
}

int main(void)
{
    int sockfd, new_fd;  // listen on sock_fd, new connection on new_fd
    struct sockaddr_in my_addr;    // my address information
    struct sockaddr_in their_addr; // connector's address information
    socklen_t sin_size;
    struct sigaction sa;
    int yes=1;

    if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }

    if (setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&amp;yes,sizeof(int)) == -1) {
        perror("setsockopt");
        exit(1);
    }
    
    my_addr.sin_family = AF_INET;         // host byte order
    my_addr.sin_port = htons(MYPORT);     // short, network byte order
    my_addr.sin_addr.s_addr = INADDR_ANY; // automatically fill with my IP
    memset(&amp;(my_addr.sin_zero), '\0', 8); // zero the rest of the struct

    if (bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof(struct sockaddr))
                                                                   == -1) {
        perror("bind");
        exit(1);
    }

    if (listen(sockfd, BACKLOG) == -1) {
        perror("listen");
        exit(1);
    }

    sa.sa_handler = sigchld_handler; // reap all dead processes
    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    if (sigaction(SIGCHLD, &amp;sa, NULL) == -1) {
        perror("sigaction");
        exit(1);
    }

    while(1) {  // main accept() loop
        sin_size = sizeof(struct sockaddr_in);
        if ((new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr,
                                                       &amp;sin_size)) == -1) {
            perror("accept");
            continue;
        }
        printf("server: got connection from %s\n",
                                           inet_ntoa(their_addr.sin_addr));
        if (!fork()) { // this is the child process
            close(sockfd); // child doesn't need the listener
            if (send(new_fd, "Hello, world!\n", 14, 0) == -1)
                perror("send");
            close(new_fd);
            exit(0);
        }
        close(new_fd);  // parent doesn't need this
    }

    return 0;
} 
</pre>
</table></p>


<p>In case you're curious, I have the code in one big
<tt>main()</tt> function for (I feel) syntactic clarity.
Feel free to split it into smaller functions if it makes you feel
better.</p>

<p>(Also, this whole <tt>sigaction()</tt> thing might be
new to you--that's ok.  The code that's there is responsible for reaping
zombie processes that appear as the <tt>fork()</tt>ed child
processes exit.  If you make lots of zombies and don't reap them, your
system administrator will become agitated.)</p>

<p>You can get the data from this server by using the client
listed in the next section.</p>



<!--  =======================================================  -->

<!--  simpleclient  -->

<!--  =======================================================  -->




<p><br/><h3>5.2. <a name="simpleclient">A Simple Stream Client</a></h3></p>


<p>This guy's even easier than the server.  All this client does is
connect to the host you specify on the command line, port 3490.  It gets
the string that the server sends.</p>

<p><a href="http://beej.us/guide/bgnet/examples/client.c">The client
source</a>:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
/*
** client.c -- a stream socket client demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;

#define PORT 3490 // the port client will be connecting to 

#define MAXDATASIZE 100 // max number of bytes we can get at once 

int main(int argc, char *argv[])
{
    int sockfd, numbytes;  
    char buf[MAXDATASIZE];
    struct hostent *he;
    struct sockaddr_in their_addr; // connector's address information 

    if (argc != 2) {
        fprintf(stderr,"usage: client hostname\n");
        exit(1);
    }

    if ((he=gethostbyname(argv[1])) == NULL) {  // get the host info 
        herror("gethostbyname");
        exit(1);
    }

    if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }

    their_addr.sin_family = AF_INET;    // host byte order 
    their_addr.sin_port = htons(PORT);  // short, network byte order 
    their_addr.sin_addr = *((struct in_addr *)he-&gt;h_addr);
    memset(&amp;(their_addr.sin_zero), '\0', 8);  // zero the rest of the struct 

    if (connect(sockfd, (struct sockaddr *)&amp;their_addr,
                                          sizeof(struct sockaddr)) == -1) {
        perror("connect");
        exit(1);
    }

    if ((numbytes=recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
        perror("recv");
        exit(1);
    }

    buf[numbytes] = '\0';

    printf("Received: %s",buf);

    close(sockfd);

    return 0;
} 
</pre>
</table></p>


<p>Notice that if you don't run the server before you run the client,
<tt>connect()</tt> returns "Connection refused".  Very
useful.</p>



<!--  =======================================================  -->

<!--  datagram  -->

<!--  =======================================================  -->




<p><br/><h3>5.3. <a name="datagram">Datagram Sockets</a></h3></p>


<p>I really don't have that much to talk about here, so I'll just
present a couple of sample programs: <i><tt>talker.c</tt></i> and
<i><tt>listener.c</tt></i>.</p>

<p><b><tt>listener</tt></b> sits on a machine waiting for an
incoming packet on port 4950.  <b><tt>talker</tt></b> sends a packet
to that port, on the specified machine, that contains whatever the user
enters on the command line.</p>

<p>Here is the <a href="http://beej.us/guide/bgnet/examples/listener.c">source for
<i><tt>listener.c</tt></i></a>:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
/*
** listener.c -- a datagram sockets "server" demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

#define MYPORT 4950    // the port users will be connecting to

#define MAXBUFLEN 100

int main(void)
{
    int sockfd;
    struct sockaddr_in my_addr;    // my address information
    struct sockaddr_in their_addr; // connector's address information
    socklen_t addr_len;
    int numbytes;
    char buf[MAXBUFLEN];

    if ((sockfd = socket(PF_INET, SOCK_DGRAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }

    my_addr.sin_family = AF_INET;         // host byte order
    my_addr.sin_port = htons(MYPORT);     // short, network byte order
    my_addr.sin_addr.s_addr = INADDR_ANY; // automatically fill with my IP
    memset(&amp;(my_addr.sin_zero), '\0', 8); // zero the rest of the struct

    if (bind(sockfd, (struct sockaddr *)&amp;my_addr,
        sizeof(struct sockaddr)) == -1) {
        perror("bind");
        exit(1);
    }

    addr_len = sizeof(struct sockaddr);
    if ((numbytes=recvfrom(sockfd, buf, MAXBUFLEN-1 , 0,
        (struct sockaddr *)&amp;their_addr, &amp;addr_len)) == -1) {
        perror("recvfrom");
        exit(1);
    }

    printf("got packet from %s\n",inet_ntoa(their_addr.sin_addr));
    printf("packet is %d bytes long\n",numbytes);
    buf[numbytes] = '\0';
    printf("packet contains \"%s\"\n",buf);

    close(sockfd);

    return 0;
} 
</pre>
</table></p>


<p>Notice that in our call to <tt>socket()</tt> we're
finally using <b><tt>SOCK_DGRAM</tt></b>.  Also, note that there's
no need to <tt>listen()</tt> or
<tt>accept()</tt>.  This is one of the perks of using
unconnected datagram sockets!</p>

<p>Next comes the <a href="http://beej.us/guide/bgnet/examples/talker.c">source for
<i><tt>talker.c</tt></i></a>:</p>

<!--  BEGIN talker.c  -->

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>/*
** talker.c -- a datagram "client" demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define SERVERPORT 4950    // the port users will be connecting to

int main(int argc, char *argv[])
{
    int sockfd;
    struct sockaddr_in their_addr; // connector's address information
    struct hostent *he;
    int numbytes;

    if (argc != 3) {
        fprintf(stderr,"usage: talker hostname message\n");
        exit(1);
    }

    if ((he=gethostbyname(argv[1])) == NULL) {  // get the host info
        perror("gethostbyname");
        exit(1);
    }

    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }

    their_addr.sin_family = AF_INET;     // host byte order
    their_addr.sin_port = htons(SERVERPORT); // short, network byte order
    their_addr.sin_addr = *((struct in_addr *)he-&gt;h_addr);
    memset(&amp;(their_addr.sin_zero), '\0', 8);  // zero the rest of the struct

    if ((numbytes = sendto(sockfd, argv[2], strlen(argv[2]), 0,
             (struct sockaddr *)&amp;their_addr, sizeof(struct sockaddr))) == -1) {
        perror("sendto");
        exit(1);
    }

    printf("sent %d bytes to %s\n", numbytes, inet_ntoa(their_addr.sin_addr));

    close(sockfd);

    return 0;
}</pre>
</table></p>

<!--  END talker.c  -->


<p>And that's all there is to it!  Run <b><tt>listener</tt></b> on
some machine, then run <b><tt>talker</tt></b> on another.  Watch them
communicate!  Fun G-rated excitement for the entire nuclear
family!</p>

<p>Except for one more tiny detail that I've mentioned many times in
the past: connected datagram sockets.  I need to talk about this here,
since we're in the datagram section of the document.  Let's say that
<b><tt>talker</tt></b> calls <tt>connect()</tt> and
specifies the <b><tt>listener</tt></b>'s address.  From that point
on, <b><tt>talker</tt></b> may only sent to and receive from the
address specified by <tt>connect()</tt>.  For this reason,
you don't have to use <tt>sendto()</tt> and
<tt>recvfrom()</tt>; you can simply use
<tt>send()</tt> and <tt>recv()</tt>.</p>



 <!--  clientserver  -->


<!--  =======================================================  -->

<!--  advanced  -->

<!--  =======================================================  -->




<p><br/><hr/><h2>6. <a name="advanced">Slightly Advanced Techniques</a></h2></p>


<p>These aren't <i>really</i> advanced, but they're
getting out of the more basic levels we've already covered.  In fact, if
you've gotten this far, you should consider yourself fairly accomplished
in the basics of Unix network programming!  Congratulations!</p>

<p>So here we go into the brave new world of some of the more
esoteric things you might want to learn about sockets.  Have at
it!</p>

<!--  =======================================================  -->

<!--  blocking  -->

<!--  =======================================================  -->




<p><br/><h3>6.1. <a name="blocking">Blocking</a></h3></p>


<p>Blocking.  You've heard about it--now what the heck is it?  In a
nutshell, "block" is techie jargon for "sleep".  You probably noticed
that when you run <b><tt>listener</tt></b>, above, it just sits there
until a packet arrives.  What happened is that it called
<tt>recvfrom()</tt>, there was no data, and so
<tt>recvfrom()</tt> is said to "block" (that is, sleep
there) until some data arrives.</p>

<p>Lots of functions block.  <tt>accept()</tt> blocks.
All the <tt>recv()</tt> functions block.  The reason they
can do this is because they're allowed to.  When you first create the
socket descriptor with <tt>socket()</tt>, the kernel sets it
to blocking.  If you don't want a socket to be blocking, you have to
make a call to <tt>fcntl()</tt>:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
.
.
.
sockfd = socket(PF_INET, SOCK_STREAM, 0);
fcntl(sockfd, F_SETFL, O_NONBLOCK);
.
.
. 
</pre>
</table></p>


<p>By setting a socket to non-blocking, you can effectively "poll"
the socket for information.  If you try to read from a non-blocking
socket and there's no data there, it's not allowed to block--it will
return <b><tt>-1</tt></b> and <i><tt>errno</tt></i> will be
set to <b><tt>EWOULDBLOCK</tt></b>.</p>

<p>Generally speaking, however, this type of polling is a bad idea.
If you put your program in a busy-wait looking for data on the socket,
you'll suck up CPU time like it was going out of style.  A more elegant
solution for checking to see if there's data waiting to be read comes in
the following section on <tt>select()</tt>.</p>



<!--  =======================================================  -->

<!--  select  -->

<!--  =======================================================  -->




<p><br/><h3>6.2. <a name="select"><tt>select()</tt>--Synchronous I/O Multiplexing</a></h3></p>


<p>This function is somewhat strange, but it's very useful.  Take the
following situation: you are a server and you want to listen for
incoming connections as well as keep reading from the connections you
already have.</p>

<p>No problem, you say, just an <tt>accept()</tt> and a
couple of <tt>recv()</tt>s.  Not so fast, buster!  What if
you're blocking on an <tt>accept()</tt> call?  How are you
going to <tt>recv()</tt> data at the same time?  "Use
non-blocking sockets!"  No way!  You don't want to be a CPU hog.  What,
then?</p>

<p><tt>select()</tt> gives you the power to monitor
several sockets at the same time.  It'll tell you which ones are ready
for reading, which are ready for writing, and which sockets have raised
exceptions, if you really want to know that.</p>

<p>Without any further ado, I'll offer the synopsis of
<tt>select()</tt>:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int select(int numfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout); 
</pre>
</table></p>


<p>The function monitors "sets" of file descriptors; in particular
<i><tt>readfds</tt></i>, <i><tt>writefds</tt></i>, and
<i><tt>exceptfds</tt></i>.  If you want to see if you can read
from standard input and some socket descriptor,
<i><tt>sockfd</tt></i>, just add the file descriptors
<b><tt>0</tt></b> and <i><tt>sockfd</tt></i> to the set
<i><tt>readfds</tt></i>.  The parameter
<i><tt>numfds</tt></i> should be set to the values of the highest
file descriptor plus one.  In this example, it should be set to
<i><tt>sockfd+1</tt></i>, since it is assuredly higher than
standard input (<b><tt>0</tt></b>).</p>

<p>When <tt>select()</tt> returns,
<i><tt>readfds</tt></i> will be modified to reflect which of the
file descriptors you selected which is ready for reading.  You can test
them with the macro <tt>FD_ISSET()</tt>, below.</p>

<p>Before progressing much further, I'll talk about how to manipulate
these sets.  Each set is of the type <tt>fd_set</tt>.  The following
macros operate on this type:</p>

<ul>


<li><tt>FD_ZERO(fd_set *set)</tt> -- clears a
file descriptor set</li>


<li><tt>FD_SET(int fd, fd_set *set)</tt> -- adds
<i><tt>fd</tt></i> to the set</li>


<li><tt>FD_CLR(int fd, fd_set *set)</tt> --
removes <i><tt>fd</tt></i> from the set</li>


<li><tt>FD_ISSET(int fd, fd_set *set)</tt> --
tests to see if <i><tt>fd</tt></i> is in the
set</li>


</ul>


<p>Finally, what is this weirded out <tt>struct timeval</tt>?
Well, sometimes you don't want to wait forever for someone to send you
some data.  Maybe every 96 seconds you want to print "Still Going..." to
the terminal even though nothing has happened.  This time structure
allows you to specify a timeout period.  If the time is exceeded and
<tt>select()</tt> still hasn't found any ready file
descriptors, it'll return so you can continue processing.</p>

<p>The <tt>struct timeval</tt> has the follow fields:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
struct timeval {
    int tv_sec;     // seconds
    int tv_usec;    // microseconds
}; 
</pre>
</table></p>


<p>Just set <i><tt>tv_sec</tt></i> to the number of seconds to
wait, and set <i><tt>tv_usec</tt></i> to the number of
microseconds to wait.  Yes, that's <i>micro</i>seconds,
not milliseconds.  There are 1,000 microseconds in a millisecond, and
1,000 milliseconds in a second.  Thus, there are 1,000,000 microseconds
in a second.  Why is it "usec"?  The "u" is supposed to look like the
Greek letter &#x03BC; (Mu) that we use for "micro".  Also, when the function
returns, <i><tt>timeout</tt></i> <i>might</i> be
updated to show the time still remaining.  This depends on what flavor
of Unix you're running.</p>

<p>Yay!  We have a microsecond resolution timer!  Well, don't count
on it.  Standard Unix timeslice is around 100 milliseconds, so you might
have to wait that long no matter how small you set your <tt>struct
timeval</tt>.</p>

<p>Other things of interest:  If you set the fields in your
<tt>struct timeval</tt> to <b><tt>0</tt></b>,
<tt>select()</tt> will timeout immediately, effectively
polling all the file descriptors in your sets.  If you set the
parameter <i><tt>timeout</tt></i> to NULL, it will never timeout,
and will wait until the first file descriptor is ready.  Finally, if you
don't care about waiting for a certain set, you can just set it to NULL
in the call to <tt>select()</tt>.</p>

<p><a href="http://beej.us/guide/bgnet/examples/select.c">The following code snippet</a> waits 2.5 seconds for
something to appear on standard input:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
/*
** select.c -- a select() demo
*/

#include &lt;stdio.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

#define STDIN 0  // file descriptor for standard input

int main(void)
{
    struct timeval tv;
    fd_set readfds;

    tv.tv_sec = 2;
    tv.tv_usec = 500000;

    FD_ZERO(&amp;readfds);
    FD_SET(STDIN, &amp;readfds);

    // don't care about writefds and exceptfds:
    select(STDIN+1, &amp;readfds, NULL, NULL, &amp;tv);

    if (FD_ISSET(STDIN, &amp;readfds))
        printf("A key was pressed!\n");
    else
        printf("Timed out.\n");

    return 0;
} 
</pre>
</table></p>


<p>If you're on a line buffered terminal, the key you hit should be
RETURN or it will time out anyway.</p>

<p>Now, some of you might think this is a great way to wait for data
on a datagram socket--and you are right: it <i>might</i>
be.  Some Unices can use select in this manner, and some can't.  You
should see what your local man page says on the matter if you want to
attempt it.</p>

<p>Some Unices update the time in your <tt>struct timeval</tt> to
reflect the amount of time still remaining before a timeout.  But others
do not.  Don't rely on that occurring if you want to be portable.  (Use
<tt>gettimeofday()</tt> if you need to track time
elapsed.  It's a bummer, I know, but that's the way it is.)</p>

<p>What happens if a socket in the read set closes the connection?
Well, in that case, <tt>select()</tt> returns with that
socket descriptor set as "ready to read".  When you actually do
<tt>recv()</tt> from it, <tt>recv()</tt> will
return <b><tt>0</tt></b>.  That's how you know the client has
closed the connection.</p>

<p>One more note of interest about <tt>select()</tt>: if
you have a socket that is <tt>listen()</tt>ing, you can
check to see if there is a new connection by putting that socket's file
descriptor in the <i><tt>readfds</tt></i> set.</p>

<p>And that, my friends, is a quick overview of the almighty
<tt>select()</tt> function.</p>

<p>But, by popular demand, here is an in-depth example.
Unfortunately, the difference between the dirt-simple example, above, and
this one here is significant.  But have a look, then read the
description that follows it.</p>

<p><a href="http://beej.us/guide/bgnet/examples/selectserver.c">This program</a> acts
like a simple multi-user chat server.  Start it running in one window,
then <b><tt>telnet</tt></b> to it ("<b><tt>telnet hostname
9034</tt></b>") from multiple other windows.  When you type something
in one <b><tt>telnet</tt></b> session, it should appear in all the
others.</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
/*
** selectserver.c -- a cheezy multiperson chat server
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

#define PORT 9034   // port we're listening on

int main(void)
{
    fd_set master;   // master file descriptor list
    fd_set read_fds; // temp file descriptor list for select()
    struct sockaddr_in myaddr;     // server address
    struct sockaddr_in remoteaddr; // client address
    int fdmax;        // maximum file descriptor number
    int listener;     // listening socket descriptor
    int newfd;        // newly accept()ed socket descriptor
    char buf[256];    // buffer for client data
    int nbytes;
    int yes=1;        // for setsockopt() SO_REUSEADDR, below
    socklen_t addrlen;
    int i, j;

    FD_ZERO(&amp;master);    // clear the master and temp sets
    FD_ZERO(&amp;read_fds);

    // get the listener
    if ((listener = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }

    // lose the pesky "address already in use" error message
    if (setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes,
                                                        sizeof(int)) == -1) {
        perror("setsockopt");
        exit(1);
    }

    // bind
    myaddr.sin_family = AF_INET;
    myaddr.sin_addr.s_addr = INADDR_ANY;
    myaddr.sin_port = htons(PORT);
    memset(&amp;(myaddr.sin_zero), '\0', 8);
    if (bind(listener, (struct sockaddr *)&amp;myaddr, sizeof(myaddr)) == -1) {
        perror("bind");
        exit(1);
    }

    // listen
    if (listen(listener, 10) == -1) {
        perror("listen");
        exit(1);
    }

    // add the listener to the master set
    FD_SET(listener, &amp;master);

    // keep track of the biggest file descriptor
    fdmax = listener; // so far, it's this one

    // main loop
    for(;;) {
        read_fds = master; // copy it
        if (select(fdmax+1, &amp;read_fds, NULL, NULL, NULL) == -1) {
            perror("select");
            exit(1);
        }

        // run through the existing connections looking for data to read
        for(i = 0; i &lt;= fdmax; i++) {
            if (FD_ISSET(i, &amp;read_fds)) { // we got one!!
                if (i == listener) {
                    // handle new connections
                    addrlen = sizeof(remoteaddr);
                    if ((newfd = accept(listener, (struct sockaddr *)&amp;remoteaddr,
                                                             &amp;addrlen)) == -1) { 
                        perror("accept");
                    } else {
                        FD_SET(newfd, &amp;master); // add to master set
                        if (newfd &gt; fdmax) {    // keep track of the maximum
                            fdmax = newfd;
                        }
                        printf("selectserver: new connection from %s on "
                            "socket %d\n", inet_ntoa(remoteaddr.sin_addr), newfd);
                    }
                } else {
                    // handle data from a client
                    if ((nbytes = recv(i, buf, sizeof(buf), 0)) &lt;= 0) {
                        // got error or connection closed by client
                        if (nbytes == 0) {
                            // connection closed
                            printf("selectserver: socket %d hung up\n", i);
                        } else {
                            perror("recv");
                        }
                        close(i); // bye!
                        FD_CLR(i, &amp;master); // remove from master set
                    } else {
                        // we got some data from a client
                        for(j = 0; j &lt;= fdmax; j++) {
                            // send to everyone!
                            if (FD_ISSET(j, &amp;master)) {
                                // except the listener and ourselves
                                if (j != listener &amp;&amp; j != i) {
                                    if (send(j, buf, nbytes, 0) == -1) {
                                        perror("send");
                                    }
                                }
                            }
                        }
                    }
                } // it's SO UGLY!
            }
        }
    }
    
    return 0;
} 
</pre>
</table></p>


<p>Notice I have two file descriptor sets in the code:
<i><tt>master</tt></i> and <i><tt>read_fds</tt></i>.  The
first, <i><tt>master</tt></i>, holds all the socket descriptors
that are currently connected, as well as the socket descriptor that is
listening for new connections.</p>

<p>The reason I have the <i><tt>master</tt></i> set is that
<tt>select()</tt> actually <i>changes</i> the
set you pass into it to reflect which sockets are ready to read.  Since
I have to keep track of the connections from one call of
<tt>select()</tt> to the next, I must store these safely
away somewhere.  At the last minute, I copy the
<i><tt>master</tt></i> into the <i><tt>read_fds</tt></i>,
and then call <tt>select()</tt>.</p>

<p>But doesn't this mean that every time I get a new connection, I
have to add it to the <i><tt>master</tt></i> set?  Yup!  And
every time a connection closes, I have to remove it from the
<i><tt>master</tt></i> set?  Yes, it does.</p>

<p>Notice I check to see when the <i><tt>listener</tt></i>
socket is ready to read.  When it is, it means I have a new connection
pending, and I <tt>accept()</tt> it and add it to the
<i><tt>master</tt></i> set.  Similarly, when a client connection
is ready to read, and <tt>recv()</tt> returns
<b><tt>0</tt></b>, I know the client has closed the connection, and
I must remove it from the <i><tt>master</tt></i> set.</p>

<p>If the client <tt>recv()</tt> returns non-zero,
though, I know some data has been received.  So I get it, and then go
through the <i><tt>master</tt></i> list and send that data to all
the rest of the connected clients.</p>

<p>And that, my friends, is a less-than-simple overview of the
almighty <tt>select()</tt> function.</p>



<!--  =======================================================  -->

<!--  sendall  -->

<!--  =======================================================  -->




<p><br/><h3>6.3. <a name="sendall">Handling Partial <tt>send()</tt>s</a></h3></p>


<p>Remember back in the <a href="#sendrecv">section about
<tt>send()</tt></a>, above, when I said that
<tt>send()</tt> might not send all the bytes you asked it
to?  That is, you want it to send 512 bytes, but it returns 412.  What
happened to the remaining 100 bytes?</p>

<p>Well, they're still in your little buffer waiting to be sent out.
Due to circumstances beyond your control, the kernel decided not to send
all the data out in one chunk, and now, my friend, it's up to you to get
the data out there.</p>

<p>You could write a function like this to do it, too:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int sendall(int s, char *buf, int *len)
{
    int total = 0;        // how many bytes we've sent
    int bytesleft = *len; // how many we have left to send
    int n;

    while(total &lt; *len) {
        n = send(s, buf+total, bytesleft, 0);
        if (n == -1) { break; }
        total += n;
        bytesleft -= n;
    }

    *len = total; // return number actually sent here

    return n==-1?-1:0; // return -1 on failure, 0 on success
} 
</pre>
</table></p>


<p>In this example, <i><tt>s</tt></i> is the socket you want
to send the data to, <i><tt>buf</tt></i> is the buffer containing
the data, and <i><tt>len</tt></i> is a pointer to an
<tt>int</tt> containing the number of bytes in the buffer.</p>

<p>The function returns <b><tt>-1</tt></b> on error (and
<i><tt>errno</tt></i> is still set from the call to
<tt>send()</tt>.)  Also, the number of bytes actually sent
is returned in <i><tt>len</tt></i>.  This will be the same number
of bytes you asked it to send, unless there was an error.
<tt>sendall()</tt> will do it's best, huffing and puffing,
to send the data out, but if there's an error, it gets back to you right
away.</p>

<p>For completeness, here's a sample call to the function:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
char buf[10] = "Beej!";
int len;

len = strlen(buf);
if (sendall(s, buf, &amp;len) == -1) {
    perror("sendall");
    printf("We only sent %d bytes because of the error!\n", len);
} 
</pre>
</table></p>


<p>What happens on the receiver's end when part of a packet arrives?
If the packets are variable length, how does the receiver know when one
packet ends and another begins?  Yes, real-world scenarios are a royal
pain in the donkeys.  You probably have to
<i>encapsulate</i> (remember that from the <a href="#lowlevel">data encapsulation section</a> way back there at
the beginning?)  Read on for details!</p>



<!--  =======================================================  -->

<!--  sonofdataencap  -->

<!--  =======================================================  -->




<p><br/><h3>6.4. <a name="sonofdataencap">Son of Data Encapsulation</a></h3></p>


<p>What does it really mean to encapsulate data, anyway?  In the
simplest case, it means you'll stick a header on there with either some
identifying information or a packet length, or both.</p>

<p>What should your header look like?  Well, it's just some binary
data that represents whatever you feel is necessary to complete your
project.</p>

<p>Wow.  That's vague.</p>

<p>Okay.  For instance, let's say you have a multi-user chat program
that uses <b><tt>SOCK_STREAM</tt></b>s.  When a user types ("says")
something, two pieces of information need to be transmitted to the
server: what was said and who said it.</p>

<p>So far so good?  "What's the problem?" you're asking.</p>

<p>The problem is that the messages can be of varying lengths.  One
person named "tom" might say, "Hi", and another person named
"Benjamin" might say, "Hey guys what is up?"</p>

<p>So you <tt>send()</tt> all this stuff to the clients
as it comes in.  Your outgoing data stream looks like this:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
t o m H i B e n j a m i n H e y g u y s w h a t i s u p ?
</pre>
</table></p>


<p>And so on.  How does the client know when one message starts and
another stops?  You could, if you wanted, make all messages the same
length and just call the <tt>sendall()</tt> we implemented,
<a href="#sendall">above</a>.  But that wastes bandwidth!  We
don't want to <tt>send()</tt> 1024 bytes just so "tom" can
say "Hi".</p>

<p>So we <i>encapsulate</i> the data in a tiny header
and packet structure.  Both the client and server know how to pack and
unpack (sometimes referred to as "marshal" and "unmarshal") this data.
Don't look now, but we're starting to define a
<i>protocol</i> that describes how a client and server
communicate!</p>

<p>In this case, let's assume the user name is a fixed length of 8
characters, padded with <b><tt>'\0'</tt></b>.  And then let's
assume the data is variable length, up to a maximum of 128
characters.  Let's have a look a sample packet structure that we might
use in this situation:</p>

<ol>


<li><tt>len</tt> (1 byte, unsigned)
-- The total length of the packet, counting the 8-byte user name and
chat data.</li>


<li><tt>name</tt> (8 bytes) -- The
user's name, NUL-padded if necessary.</li>


<li><tt>chatdata</tt>
(<i>n</i>-bytes) -- The data itself, no more than 128
bytes.  The length of the packet should be calculated as the length of
this data plus 8 (the length of the name field,
above).</li>


</ol>


<p>Why did I choose the 8-byte and 128-byte limits for the fields?  I
pulled them out of the air, assuming they'd be long enough.  Maybe,
though, 8 bytes is too restrictive for your needs, and you can have a
30-byte name field, or whatever.  The choice is up to you.</p>

<p>Using the above packet definition, the first packet would consist
of the following information (in hex and ASCII):</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
   0A     74 6F 6D 00 00 00 00 00      48 69
 (length)  T  o  m    (padding)         H  i
</pre>
</table></p>


<p>And the second is similar:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
   14     42 65 6E 6A 61 6D 69 6E      48 65 79 20 67 75 79 73 20 77 ...
 (length)  B  e  n  j  a  m  i  n       H  e  y     g  u  y  s     w ...
</pre>
</table></p>


<p>(The length is stored in Network Byte Order, of course.  In this
case, it's only one byte so it doesn't matter, but generally speaking
you'll want all your binary integers to be stored in Network Byte Order
in your packets.)</p>

<p>When you're sending this data, you should be safe and use a
command similar to <a href="#sendall"><tt>sendall()</tt></a>, above, so you
know all the data is sent, even if it takes multiple calls to
<tt>send()</tt> to get it all out.</p>

<p>Likewise, when you're receiving this data, you need to do a bit of extra
work.  To be safe, you should assume that you might receive a partial
packet (like maybe we receive "<tt>14 42 65
6E</tt>" from Benjamin, above, but that's all we get in this
call to <tt>recv()</tt>).  We need to call
<tt>recv()</tt> over and over again until the packet is
completely received.</p>

<p>But how?  Well, we know the number of bytes we need to receive in
total for the packet to be complete, since that number is tacked on the
front of the packet.  We also know the maximum packet size is 1+8+128,
or 137 bytes (because that's how we defined the packet.)</p>

<p>What you can do is declare an array big enough for two packets.
This is your work array where you will reconstruct packets as they
arrive.</p>

<p>Every time you <tt>recv()</tt> data, you'll feed it
into the work buffer and check to see if the packet is complete.  That
is, the number of bytes in the buffer is greater than or equal to the
length specified in the header (+1, because the length in the header
doesn't include the byte for the length itself.)  If the number of bytes
in the buffer is less than 1, the packet is not complete, obviously.
You have to make a special case for this, though, since the first byte
is garbage and you can't rely on it for the correct packet
length.</p>

<p>Once the packet is complete, you can do with it what you
will.  Use it, and remove it from your work buffer.</p>

<p>Whew!  Are you juggling that in your head yet?  Well, here's the
second of the one-two punch: you might have read past the end of one
packet and onto the next in a single <tt>recv()</tt> call.
That is, you have a work buffer with one complete packet, and an
incomplete part of the next packet!  Bloody heck.  (But this is why you
made your work buffer large enough to hold <i>two</i>
packets--in case this happened!)</p>

<p>Since you know the length of the first packet from the header, and
you've been keeping track of the number of bytes in the work buffer, you
can subtract and calculate how many of the bytes in the work buffer
belong to the second (incomplete) packet.  When you've handled the first
one, you can clear it out of the work buffer and move the partial second
packed down the to front of the buffer so it's all ready to go for the
next <tt>recv()</tt>.</p>

<p>(Some of you readers will note that actually moving the partial
second packet to the beginning of the work buffer takes time, and the
program can be coded to not require this by using a circular buffer.
Unfortunately for the rest of you, a discussion on circular buffers is
beyond the scope of this article.  If you're still curious, grab a data
structures book and go from there.)</p>

<p>I never said it was easy.  Ok, I did say it was easy.  And it is;
you just need practice and pretty soon it'll come to you naturally.  By
Excalibur I swear it!</p>

 <!--  sonofdataencap  -->


<!--  =======================================================  -->

<!--  broadcast  -->

<!--  =======================================================  -->



<p><br/><h3>6.5. <a name="broadcast">Broadcast Packets--Hello, World!</a></h3></p>


<p>So far, this guide has talked about sending data from one host to one
other host.  But it is possible, I insist, that you can, with the proper
authority, send data to multiple hosts <i>at the same time</i>!</p>

<p>With UDP (only UDP, not TCP) and standard IPv4, this is done through
a mechanism called <i>broadcasting</i>.  With IPv6 (not appearing in
this guide...yet), broadcasting isn't supported, and you have to resort
to the often superior technique of <i>multicasting</i>.  But enough
of the starry-eyed future--we're stuck in the 32-bit present.</p>

<p>But wait!  You can't just run off and start broadcasting willy-nilly;
You have to set the socket option <b><tt>SO_BROADCAST</tt></b> before you
can send a broadcast packet out on the network.  It's like a one of
those little plastic covers they put over the missile launch switch!
That's just how much power you hold in your hands!</p>

<p>But seriously, though, there is a danger to using broadcast packets,
and that is: every system that recieves a broadcast packet must undo all
the onion-skin layers of data encapsulation until it finds out what port
the data is destined to.  And then it hands the data over or discards
it.  In either case, it's a lot of work for each machine that recieves
the broadcast packet, and since it is all of them on the local network,
that could be a lot of machines doing a lot of unnecessary work.  When
the game Doom first came out, this was a complaint about its network
code.</p>

<p>Yes, I said the local network.  There is more than one way to skin a
cat... wait a minute.  Is there really more than one way to skin a cat?
What kind of expression is that?  Uh, and likewise, there is more than
one way to send a broadcast packet, but the broadcast packets will
usually be restricted to your local network no matter how you send
them.</p>

<p>So now to the meat and potatoes of the whole thing: how do you
specify the destination address for a broadcast message?  There are two
common ways.</p>

<ol>

<li>Send the data to your broadcast address.  This is your network
number with all one-bits set for the host portion of the address.  For
instance, at home my network is 192.168.1.0, my netmask is
255.255.255.0, so the last byte of the address is my host number
(because the first three bytes, according to the netmask, are the
network number).  So my broadcast address is 192.168.1.255.  Under Unix,
the <b><tt>ifconfig</tt></b> command will actually give you all this data.
(If you're curious, the bitwise logic to get your broadcast address is
<b><tt>network_number</tt></b> OR (NOT <b><tt>netmask</tt></b>).)</li>


<li>Send the data to the "global" broadcast address.  This is
255.255.255.255, aka <b><tt>INADDR_BROADCAST</tt></b>.  Many machines
will automatically bitwise AND this with your network number to convert
it to a network broadcast address, but some won't.  It varies.</li>

</ol>


<p>So what happens if you try to send data on the broadcast address
without first setting the <b><tt>SO_BROADCAST</tt></b> socket option?
Well, let's fire up good old <a href="#datagram"><b><tt>talker</tt></b> and
<b><tt>listener</tt></b></a> and see what happens.</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
$ talker 192.168.1.2 foo
sent 3 bytes to 192.168.1.2
$ talker 192.168.1.255 foo
sendto: Permission denied
$ talker 255.255.255.255 foo
sendto: Permission denied
</pre>
</table></p>


<p>Yes, it's not happy at all...because we didn't set the
<b><tt>SO_BROADCAST</tt></b> socket option.  Do that, and now you can
<tt>sendto()</tt> anywhere you want!</p>

<p>In fact, that's the <i>only difference</i> between a UDP
application that can broadcast and one that can't.  So let's take the
old <b><tt>talker</tt></b> application and add one section that sets the
<b><tt>SO_BROADCAST</tt></b> socket option.  We'll call this program
<a href="http://beej.us/guide/bgnet/examples/broadcaster.c">
<i><tt>broadcaster.c</tt></i></a>:</p>

<!--  BEGIN broadcaster.c  -->

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>/*
** broadcaster.c -- a datagram "client" like talker.c, except
**                  this one can broadcast
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define SERVERPORT 4950    // the port users will be connecting to

int main(int argc, char *argv[])
{
    int sockfd;
    struct sockaddr_in their_addr; // connector's address information
    struct hostent *he;
    int numbytes;
    int broadcast = 1;
    //char broadcast = '1'; // if that doesn't work, try this

    if (argc != 3) {
        fprintf(stderr,"usage: broadcaster hostname message\n");
        exit(1);
    }

    if ((he=gethostbyname(argv[1])) == NULL) {  // get the host info
        perror("gethostbyname");
        exit(1);
    }

    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }

    // this call is the difference between this program and talker.c:
    if (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;broadcast,
        sizeof(broadcast)) == -1) {
        perror("setsockopt (SO_BROADCAST)");
        exit(1);
    }

    their_addr.sin_family = AF_INET;     // host byte order
    their_addr.sin_port = htons(SERVERPORT); // short, network byte order
    their_addr.sin_addr = *((struct in_addr *)he-&gt;h_addr);
    memset(&amp;(their_addr.sin_zero), '\0', 8);  // zero the rest of the struct

    if ((numbytes=sendto(sockfd, argv[2], strlen(argv[2]), 0,
             (struct sockaddr *)&amp;their_addr, sizeof(struct sockaddr))) == -1) {
        perror("sendto");
        exit(1);
    }

    printf("sent %d bytes to %s\n", numbytes, inet_ntoa(their_addr.sin_addr));

    close(sockfd);

    return 0;
}</pre>
</table></p>

<!--  END broadcaster.c  -->


<p>What's different between this and a "normal" UDP client/server
situation?  Nothing!  (With the exception of the client being allowed to
send broadcast packets in this case.)  As such, go ahead and run the old
UDP <a href="#datagram"><b><tt>listener</tt></b></a> program in one
window, and <b><tt>broadcaster</tt></b> in another.  You should be now be
able to do all those sends that failed, above.</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
$ talker 192.168.1.2 foo
sent 3 bytes to 192.168.1.2
$ talker 192.168.1.255 foo
sent 3 bytes to 192.168.1.255
$ talker 255.255.255.255 foo
sent 3 bytes to 255.255.255.255
</pre>
</table></p>


<p>And you should see <b><tt>listener</tt></b> responding that it got the
packets.</p>

<p>Well, that's kind of exciting.  But now fire up <b><tt>listener</tt></b> on
another machine next to you on the same network so that you have two
copies going, one on each machine, and run <b><tt>broadcaster</tt></b> again
with your broadcast address... Hey!  Both <b><tt>listener</tt></b>s get the
packet even though you only called <tt>sendto()</tt> once!
Cool!</p>

<p>If the <b><tt>listener</tt></b> gets data you send directly to it, but not
data on the broadcast address, it could be that you have a firewall on
your local machine that is blocking the packets.  (Yes, Pat and Bapper,
thank you for realizing before I did that this is why my sample code
wasn't working.  I told you I'd mention you in the guide, and here you
are.  So <i>nyah</i>.)</p>

<p>Again, be careful with broadcast packets.  Since every machine on the
LAN will be forced to deal with the packet whether it
<tt>recvfrom()</tt>s it or not, it can present quite a load to the
entire computing network.  They are definitely to be used sparingly and
appropriately.</p>

 <!--  broadcast  -->


 <!--  advanced  -->


<!--  =======================================================  -->

<!--  faq  -->

<!--  =======================================================  -->




<p><br/><hr/><h2>7. <a name="faq">Common Questions</a></h2></p>


<dl>


<!--  +++++++++++++++++++++++++  -->



<dt><b>Where can I get those header files?</b></dt>


<dd><p>If you don't have them on your system already, you
probably don't need them.  Check the manual for your particular
platform.  If you're building for Windows, you only need to
<tt>#include
&lt;winsock.h&gt;</tt>.</p></dd>




<!--  +++++++++++++++++++++++++  -->



<dt><b>What do I do when <tt>bind()</tt> reports
"Address already in use"?</b></dt>


<dd><p>You have to use <tt>setsockopt()</tt> with the
<b><tt>SO_REUSEADDR</tt></b> option on the listening socket.  Check
out the <a href="#bind">section on
<tt>bind()</tt></a> and the <a href="#select">section on <tt>select()</tt></a> for an
example.</p></dd>




<!--  +++++++++++++++++++++++++  -->



<dt><b>How do I get a list of open sockets on the
system?</b></dt>


<dd><p>Use the <b><tt>netstat</tt></b>.  Check the
<b><tt>man</tt></b> page for full details, but you should get some
good output just typing:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
$ netstat
</pre>
</table></p>


<p>The only trick is determining which socket is associated with
which program. <tt>:-)</tt></p></dd>




<!--  +++++++++++++++++++++++++  -->



<dt><b>How can I view the routing table?</b></dt>


<dd><p>Run the <b><tt>route</tt></b> command (in
<i><tt>/sbin</tt></i> on most Linuxes) or the command
<b><tt>netstat -r</tt></b>.</p></dd>




<!--  +++++++++++++++++++++++++  -->



<dt><b>How can I run the client and server programs if I only
have one computer?  Don't I need a network to write network
program?</b></dt>


<dd><p>Fortunately for you, virtually all machines implement a
loopback network "device" that sits in the kernel and pretends to be a
network card.  (This is the interface listed as
"<tt>lo</tt>" in the routing table.)</p>

<p>Pretend you're logged into a machine named
"<tt>goat</tt>".  Run the client in one window
and the server in another.  Or start the server in the background
("<b><tt>server &amp;</tt></b>") and run the client in the same
window.  The upshot of the loopback device is that you can either
<b><tt>client goat</tt></b> or <b><tt>client localhost</tt></b>
(since "<tt>localhost</tt>" is likely defined in
your <i><tt>/etc/hosts</tt></i> file) and you'll have the client
talking to the server without a network!</p>

<p>In short, no changes are necessary to any of the code to make it
run on a single non-networked machine!  Huzzah!</p></dd>




<!--  +++++++++++++++++++++++++  -->



<dt><b>How can I tell if the remote side has closed
connection?</b></dt>


<dd><p>You can tell because <tt>recv()</tt> will
return <b><tt>0</tt></b>.</p></dd>




<!--  +++++++++++++++++++++++++  -->



<dt><b>How do I implement a "ping" utility?  What is ICMP?
Where can I find out more about raw sockets and
<b><tt>SOCK_RAW</tt></b>?</b></dt>


<dd><p>All your raw sockets questions will be answered in W.
Richard Stevens' UNIX Network Programming books.  See the <a href="#books">books</a> section of this guide.</p></dd>




<!--  +++++++++++++++++++++++++  -->



<dt><b>How do I build for Windows?</b></dt>


<dd><p>First, delete Windows and install Linux or BSD.
<tt>};-)</tt>.  No, actually, just see the <a href="#windows">section on building for
Windows</a> in the introduction.</p></dd>




<!--  +++++++++++++++++++++++++  -->



<dt><b>How do I build for Solaris/SunOS?  I keep getting linker
errors when I try to compile!</b></dt>


<dd><p>The linker errors happen because Sun boxes don't
automatically compile in the socket libraries.  See the <a href="#solaris">section on building for Solaris/SunOS</a> in the
introduction for an example of how to do this.</p></dd>




<!--  +++++++++++++++++++++++++  -->



<dt><b>Why does <tt>select()</tt> keep falling out
on a signal?</b></dt>


<dd><p>Signals tend to cause blocked system calls to return
<b><tt>-1</tt></b> with <i><tt>errno</tt></i> set to
<b><tt>EINTR</tt></b>.  When you set up a signal handler with
<tt>sigaction()</tt>, you can set the flag
<b><tt>SA_RESTART</tt></b>, which is supposed to restart the system
call after it was interrupted.</p>

<p>Naturally, this doesn't always work.</p>

<p>My favorite solution to this involves a
<tt>goto</tt> statement.  You know this
irritates your professors to no end, so go for it!</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
select_restart:
if ((err = select(fdmax+1, &amp;readfds, NULL, NULL, NULL)) == -1) {
    if (errno == EINTR) {
        // some signal just interrupted us, so restart
        goto select_restart;
    }
    // handle the real error here:
    perror("select");
} 
</pre>
</table></p>


<p>Sure, you don't <i>need</i> to use
<tt>goto</tt> in this case; you can use other
structures to control it.  But I think the
<tt>goto</tt> statement is actually
cleaner.</p></dd>




<!--  +++++++++++++++++++++++++  -->



<dt><b>How can I implement a timeout on a call to
<tt>recv()</tt>?</b></dt>


<dd><p>Use <a href="#select"><tt>select()</tt></a>!  It allows you to
specify a timeout parameter for socket descriptors that you're looking
to read from.  Or, you could wrap the entire functionality in a single
function, like this:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
#include &lt;unistd.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int recvtimeout(int s, char *buf, int len, int timeout)
{
    fd_set fds;
    int n;
    struct timeval tv;

    // set up the file descriptor set
    FD_ZERO(&amp;fds);
    FD_SET(s, &amp;fds);

    // set up the struct timeval for the timeout
    tv.tv_sec = timeout;
    tv.tv_usec = 0;

    // wait until timeout or data received
    n = select(s+1, &amp;fds, NULL, NULL, &amp;tv);
    if (n == 0) return -2; // timeout!
    if (n == -1) return -1; // error

    // data must be here, so do a normal recv()
    return recv(s, buf, len, 0);
}
.
.
.
// Sample call to recvtimeout():
n = recvtimeout(s, buf, sizeof(buf), 10); // 10 second timeout

if (n == -1) {
    // error occurred
    perror("recvtimeout");
}
else if (n == -2) {
    // timeout occurred
} else {
    // got some data in buf
}
.
.
. 
</pre>
</table></p>


<p>Notice that <tt>recvtimeout()</tt> returns
<b><tt>-2</tt></b> in case of a timeout.  Why not return
<b><tt>0</tt></b>?  Well, if you recall, a return value of
<b><tt>0</tt></b> on a call to <tt>recv()</tt> means
that the remote side closed the connection.  So that return value is
already spoken for, and <b><tt>-1</tt></b> means "error", so I
chose <b><tt>-2</tt></b> as my timeout indicator.</p>

</dd>




<!--  +++++++++++++++++++++++++  -->

<!--  already answered, above
<faqentry>

<q>What if I only have one computer and no network?  How is
it possible to write and test sockets programs?</q>

<a><p>It will work on a single computer exactly the same way that it
works on a networked computer.</p>

<p>That is, running the client and server on the same machine works
just as well as running them on different machines, and you don't even
have to think about the difference.</p>

<p>You can get the answer as to why this is the case if you type
"<com>route</com>":</p>

<screen>
$ route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        *               255.0.0.0       U     0      0        0 eth0
127.0.0.0       *               255.0.0.0       U     0      0        0 lo
default         mygateway       0.0.0.0         UG    0      0        0 eth0
</screen>

<p>See, all the traffic on <tt>10.x.x.x</tt>
goes to my local subnet via <tt>eth0</tt> (the
network card), but all traffic to the
<tt>127.x.x.x</tt> subnet goes to the
<tt>lo</tt>
interface (loopback&emdash;a fake "network card" inside the kernel that
handles traffic from one machine to itself.)</p>

<p>The <tt>lo</tt> interface is also used
when you try to telnet to your own IP address (at least under Linux).
So from host "frog" I can either "<com>telnet frog</com>", or
"<com>telnet localhost</com>"&emdash;localhost is
<tt>127.0.0.1</tt>&emdash;and it will use
<tt>lo</tt>.)</p>

<p>So in short, don't worry about it.  The client and server will
run on the same machine just fine.</p>

</a>

</faqentry>
 -->


<!--  +++++++++++++++++++++++++  -->




<dt><b>How do I encrypt or compress the data before sending it
through the socket?</b></dt>


<dd>

<p>One easy way to do encryption is to use SSL (secure sockets
layer), but that's beyond the scope of this guide.</p>

<p>But assuming you want to plug in or implement your own compressor
or encryption system, it's just a matter of thinking of your data as
running through a sequence of steps between both ends.  Each step
changes the data in some way.</p>

<ol>

<li>server reads data from file (or whereever)</li>

<li>server encrypts data  (you add this part)</li>

<li>server <tt>send()</tt>s encrypted data</li>

</ol>


<p>Now the other way around:</p>

<ol>

<li>client <tt>recv()</tt>s encrypted data</li>

<li>client decrypts data  (you add this part)</li>

<li>client writes data to file (or whereever)</li>

</ol>


<p>You can also do compression at the same point that you do the
encryption/decryption, above.  Or you could do both!  Just remember to
compress before you encrypt.  <tt>:)</tt></p>

<p>Just as long as the client properly undoes what the server does,
the data will be fine in the end no matter how many intermediate steps
you add.</p>

<p>So all you need to do to use my code is to find the place between
where the data is read and the data is sent (using
<tt>send()</tt>) over the network, and stick some code in
there that does the encryption.</p>

</dd>




<!--  +++++++++++++++++++++++++  -->




<dt><b>What is this "<b><tt>PF_INET</tt></b>" I keep
seeing?  Is it related to
<b><tt>AF_INET</tt></b>?</b></dt>


<dd>
<p>Yes, yes it is.  See <a href="#socket">the section on
<tt>socket()</tt></a> for details.</p>

</dd>




<!--  +++++++++++++++++++++++++  -->




<dt><b>How can I write a server that accepts shell commands
from a client and executes them?</b></dt>


<dd>

<p>For simplicity, lets say the client
<tt>connect()</tt>s, <tt>send()</tt>s, and
<tt>close()</tt>s the connection (that is, there are no
subsequent system calls without the client connecting again.)</p>

<p>The process the client follows is this:</p>

<ol>

<li><tt>connect()</tt> to server</li>

<li><tt>send("/sbin/ls &gt; /tmp/client.out")</tt></li>

<li><tt>close()</tt> the connection</li>

</ol>


<p>Meanwhile, the server is handling the data and executing
it:</p>

<ol>

<li><tt>accept()</tt> the connection from the client</li>

<li><tt>recv(str)</tt> the command string</li>

<li><tt>close()</tt> the connection</li>

<li><tt>system(str)</tt> to run the command</li>

</ol>


<p><i>Beware!</i>  Having the server execute what the
client says is like giving remote shell access and people can do things
to your account when they connect to the server.  For instance, in the
above example, what if the client sends "<b><tt>rm -rf ~</tt></b>"?
It deletes everything in your account, that's what!</p>

<p>So you get wise, and you prevent the client from using any except
for a couple utilities that you know are safe, like the
<b><tt>foobar</tt></b> utility:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
if (!strcmp(str, "foobar")) {
    sprintf(sysstr, "%s &gt; /tmp/server.out", str);
    system(sysstr);
} 
</pre>
</table></p>


<p>But you're still unsafe, unfortunately: what if the client enters
"<b><tt>foobar; rm -rf ~</tt></b>"?  The safest thing to do is to
write a little routine that puts an escape ("<b><tt>\</tt></b>")
character in front of all non-alphanumeric characters (including spaces,
if appropriate) in the arguments for the command.</p>

<p>As you can see, security is a pretty big issue when the server
starts executing things the client sends.</p>

</dd>




<!--  +++++++++++++++++++++++++  -->




<dt><b>I'm sending a slew of data, but when I
<tt>recv()</tt>, it only receives 536 bytes or 1460 bytes at
a time.  But if I run it on my local machine, it receives all the data
at the same time.  What's going on?</b></dt>


<dd>

<p>You're hitting the MTU--the maximum size the physical medium can
handle.  On the local machine, you're using the loopback device which
can handle 8K or more no problem.  But on ethernet, which can only
handle 1500 bytes with a header, you hit that limit.  Over a modem, with
576 MTU (again, with header), you hit the even lower limit.</p>

<p>You have to make sure all the data is being sent, first of all.
(See the <a href="#sendall"><tt>sendall()</tt></a>
function implementation for details.) Once you're sure of that, then you
need to call <tt>recv()</tt> in a loop until all your data
is read.</p>

<p>Read the section <a href="#sonofdataencap">Son of Data
Encapsulation</a> for details on receiving complete packets of data
using multiple calls to <tt>recv()</tt>.</p>

</dd>




<!--  +++++++++++++++++++++++++  -->




<dt><b>I'm on a Windows box and I don't have the
<tt>fork()</tt> system call or any kind of <tt>struct
sigaction</tt>.  What to do?</b></dt>


<dd>
<p>If they're anywhere, they'll be in POSIX libraries that may have
shipped with your compiler.  Since I don't have a Windows box, I really
can't tell you the answer, but I seem to remember that Microsoft has a
POSIX compatibility layer and that's where <tt>fork()</tt>
would be.  (And maybe even <tt>sigaction</tt>.)</p>

<p>Search the help that came with VC++ for "fork" or "POSIX" and see if it
gives you any clues.</p>

<p>If that doesn't work at all, ditch the
<tt>fork()</tt>/<tt>sigaction</tt> stuff and replace it
with the Win32 equivalent: <tt>CreateProcess()</tt>.  I
don't know how to use <tt>CreateProcess()</tt>--it takes a
bazillion arguments, but it should be covered in the docs that came with
VC++.</p>

</dd>




<!--  +++++++++++++++++++++++++  -->



<dt><b>How do I send data securely with TCP/IP using
encryption?</b></dt>


<dd><p>Check out the <a href="http://www.openssl.org/">OpenSSL
project</a>.</p></dd>




<!--  +++++++++++++++++++++++++  -->



<dt><b>I'm behind a firewall--how do I let people outside the
firewall know my IP address so they can connect to my
machine?</b></dt>


<dd><p>Unfortunately, the purpose of a firewall is to prevent
people outside the firewall from connecting to machines inside the
firewall, so allowing them to do so is basically considered a breach of
security.</p>

<p>This isn't to say that all is lost.  For one thing, you can still
often <tt>connect()</tt> through the firewall if it's doing
some kind of masquerading or NAT or something like that.  Just design
your programs so that you're always the one initiating the connection,
and you'll be fine.</p>

<p>If that's not satisfactory, you can ask your sysadmins to poke a
hole in the firewall so that people can connect to you.  The firewall
can forward to you either through it's NAT software, or through a proxy
or something like that.</p>

<p>Be aware that a hole in the firewall is nothing to be taken
lightly.  You have to make sure you don't give bad people access to the
internal network; if you're a beginner, it's a lot harder to make
software secure than you might imagine.</p>

<p>Don't make your sysadmin mad at me.
<tt>;-)</tt></p></dd>




<!--  +++++++++++++++++++++++++  -->

<!-- 
<faqentry>

<q>When I have two interfaces, how do I
<func>bind()</func> to an interface by name (like
"<tt>eth0</tt>") instead of IP
address?</q>

<a><p></p></a>

</faqentry>
 -->


</dl>


 <!--  faq  -->


<!--  =======================================================  -->

<!--  conclusion  -->

<!--  =======================================================  -->


<!-- 
<sect1 id="conclusion">
<title>Disclaimer and Call for Help</title>

<p>Well, that's the lot of it.  Hopefully at least some of the
information contained within this document has been remotely accurate
and I sincerely hope there aren't any glaring errors.  Well, sure, there
always are.</p>

<p>So, let this be a warning to you!  I'm sorry if any inaccuracies
contained herein have caused you any grief, but you just can't hold me
accountable.  See, I don't stand behind a single word of this document,
legally speaking.  The whole thing could be completely and utterly
wrong!</p>

<p>But it's probably not.  After all, I've spent many many hours
messing with this stuff, and implemented several TCP/IP network
utilities at work, have written multiplayer game engines, and so on.
But I'm not the sockets god; I'm just some guy.</p>

<p>By the way, if anyone has any constructive (or destructive)
criticism about this document, please send mail to
<email>&beejmail;</email> and I'll try to make an effort to set the
record straight.</p>

<p>In case you're wondering why I did this, well, I did it for the
money.  Ha!  No, really, I did it because a lot of people have asked me
socket-related questions and when I tell them I've been thinking about
putting together a socket page, they say, "Cool!"  Besides, I feel that
all this hard-earned knowledge is going to waste if I can't share it
with others.  The web just happens to be the perfect vehicle.  I
encourage others to provide similar information whenever
possible.</p>

<p>Enough of this - back to coding!  <winky/></p>
 -->

<!--  </sect1>  -->
 <!--  conclusion  -->


<!--  ================================================================
== manpages
=================================================================  -->




<p><br/><hr/><h2>8. <a name="man">Man Pages</a></h2></p>


<p>In the Unix world, there are a lot of manuals.  They have little
sections that describe individual functions that you have at your
disposal.</p>

<p>Of course, <b><tt>manual</tt></b> would be too much of a thing to type.  I
mean, no one in the Unix world, including myself, likes to type that
much.  Indeed I could go on and on at great length about how much I
prefer to be terse but instead I shall be brief and not bore you with
long-winded diatribes about how utterly amazingly brief I prefer to be
in virtually all circumstances in their entirety.</p>

<p><i>[Applause]</i></p>

<p>Thank you.  What I am getting at is that these pages are called "man
pages" in the Unix world, and I have included my own personal truncated
variant here for your reading enjoyment.  The thing is, many of these
functions are way more general purpose than I'm letting on, but I'm only
going to present the parts that are relevant for Internet Sockets
Programming.</p>

<p>But wait!  That's not all that's wrong with my man pages:</p>

<ul>

<li>They are incomplete and only show the basics from the guide.</li>

<li>There are many more man pages than this in the real world.</li>

<li>They are different than the ones on your system.</li>

<li>The header files might be different for certain functions on your
system.</li>

<li>The function parameters might be different for certain functions on your
system.</li>

</ul>


<p>If you want the real information, check your local Unix man pages by
typing <b><tt>man whatever</tt></b>, where "whatever" is something that
you're incredibly interested in, such as "<tt>accept</tt>".  (I'm sure
Microsoft Visual Studio has something similar in their help section.
But "man" is better because it is one byte more concise than "help".
Unix wins again!)</p>

<p>So, if these are so flawed, why even include them at all in the
Guide?  Well, there are a few reasons, but the best are that (a) these
versions are geared specifically toward network programming and are
easier to digest than the real ones, and (b) these versions contain
examples!</p>

<p>Oh!  And speaking of the examples, I don't tend to put in all the
error checking because it really increases the length of the code.  But
you should absolutely do error checking pretty much any time you make
any of the system calls unless you're totally 100% sure it's not going
to fail, and you should probably do it even then!</p>

<!--  ================================================================
== accept()
=================================================================  -->


<p><hr/>
<h2><a name="acceptman"><tt>accept()</tt></a></h2></p>

<p>Accept an incoming connection on a listening socket</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;sys/types.h&gt;</tt><br/>
<tt>#include &lt;sys/socket.h&gt;</tt></p>
<p><tt>int accept(int s, struct sockaddr *addr, socklen_t
*addrlen);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>Once you've gone through the trouble of getting a
<b><tt>SOCK_STREAM</tt></b> socket and setting it up for incoming
connections with <tt>listen()</tt>, then you call
<tt>accept()</tt> to actually get yourself a new socket descriptor
to use for subsequent communication with the newly connected
client.</p>

<p>The old socket that you are using for listening is still there, and
will be used for further <tt>accept()</tt> calls as they come
in.</p>

<p>
<table cellpadding="10" cellspacing="0" border="0">

<tr><td valign="top" align="left" width="20%"><p><b><tt>s</tt></b></p></td>

<td valign="top" align="left" width="78%"><p>The <tt>listen()</tt>ing socket descriptor.</p></td>
</tr>


<tr><td valign="top" align="left"<p><b><tt>addr</tt></b></p></td>

<td valign="top" align="left" width="78%"><p>This is filled in with the address of the site that's
connecting to you.</p></td>
</tr>


<tr><td valign="top" align="left"<p><b><tt>addrlen</tt></b></p></td>

<td valign="top" align="left" width="78%"><p>This is filled in with the <tt>sizeof()</tt> the
structure returned in the <b><tt>addr</tt></b> parameter.  You can safely
ignore it if you assume you're getting a <tt>struct
sockaddr_in</tt> back, which you know you are, because that's the type
you passed in for <b><tt>addr</tt></b>.</p></td>
</tr>

</table>

</p>

<p><tt>accept()</tt> will normally block, and you can use
<tt>select()</tt> to peek on the listening socket descriptor ahead
of time to see if it's "ready to read".  If so, then there's a new
connection waiting to be <tt>accept()</tt>ed!  Yay!  Alternatively,
you could set the <b><tt>O_NONBLOCK</tt></b> flag on the listening
socket using <tt>fcntl()</tt>, and then it will never block,
choosing instead to return <b><tt>-1</tt></b> with <b><tt>errno</tt></b> set
to <b><tt>EWOULDBLOCK</tt></b>.</p>

<p>The socket descriptor returned by <tt>accept()</tt> is a bona
fide socket descriptor, open and connected to the remote host.  You have
to <tt>close()</tt> it when you're done with it.</p>

</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p><tt>accept()</tt> returns the newly connected socket descriptor,
or <b><tt>-1</tt></b> on error, with <b><tt>errno</tt></b> set
appropriately.</p>
</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int s, s2;
struct sockaddr_in myaddr, remoteaddr;
socklen_t remoteaddr_len;

myaddr.sin_family = AF_INET;
myaddr.sin_port = htons(3490); // clients connect to this port
myaddr.sin_addr.s_addr = INADDR_ANY; // autoselect IP address

s = socket(PF_INET, SOCK_STREAM, 0);
bind(s, (struct sockaddr*)myaddr, sizeof(myaddr));

listen(s, 10); // set s up to be a server (listening) socket

for(;;) {
    s2 = accept(s, &amp;remoteaddr, &amp;remoteaddr_len);

    // now you can send() and recv() with the
    // connected client via socket s2
}
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#socketman"><tt>socket()</tt></a>,
<a href="#listenman"><tt>listen()</tt></a>,
<a href="#sockaddr_inman"><tt>struct sockaddr_in</tt></a></p>
</dd></dl>




<!--  ================================================================
== bind
=================================================================  -->


<p><hr/>
<h2><a name="bindman"><tt>bind()</tt></a></h2></p>

<p>Associate a socket with an IP address and port number</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;sys/types.h&gt;</tt><br/>
<tt>#include &lt;sys/socket.h&gt;</tt></p>
<p><tt>int bind(int sockfd, struct sockaddr *my_addr, socklen_t
addrlen);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>When a remote machine wants to connect to your server program, it needs
two pieces of information: the IP address and the port number.  The
<tt>bind()</tt> call allows you to do just that.</p>

<p>First, you call <tt>socket()</tt> to get a socket descriptor, and
then you load up a <tt>struct sockaddr_in</tt> with the IP address
and port number information, and then you pass both of those into
<tt>bind()</tt>, and the IP address and port are magically (using
actual magic) bound to the socket!</p>

<p>If you don't know your IP address, or you know you only have one IP
address on the machine, or you don't care which of the machine's IP
addresses is used, you can simply set the <tt>s_addr</tt> field in
your <tt>struct sockaddr_in</tt> to <b><tt>INADDR_ANY</tt></b> and it
will fill in the IP address for you.</p>

<p>Lastly, the <b><tt>addrlen</tt></b> parameter should be set to
<tt>sizeof(my_addr)</tt>.</p>
</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p>Returns zero on success, or <b><tt>-1</tt></b> on error (and
<tt>errno</tt> will be set accordingly.)</p>
</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
struct sockaddr_in myaddr;
int s;

myaddr.sin_family = AF_INET;
myaddr.sin_port = htons(3490);

// you can specify an IP address:
inet_aton("63.161.169.137", &amp;myaddr.sin_addr.s_addr);

// or you can let it automatically select one:
myaddr.sin_addr.s_addr = INADDR_ANY;

s = socket(PF_INET, SOCK_STREAM, 0);
bind(s, (struct sockaddr*)myaddr, sizeof(myaddr));
</pre>
</table></p>


</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#socketman"><tt>socket()</tt></a>,
<a href="#sockaddr_inman"><tt>struct sockaddr_in</tt></a>,
<a href="#sockaddr_inman"><tt>struct in_addr</tt></a></p>
</dd></dl>




<!--  ================================================================
== connect()
=================================================================  -->


<p><hr/>
<h2><a name="connectman"><tt>connect()</tt></a></h2></p>

<p>Connect a socket to a server</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;sys/types.h&gt;</tt><br/>
<tt>#include &lt;sys/socket.h&gt;</tt></p>
<p><tt>int connect(int sockfd, const struct sockaddr *serv_addr,</tt><br/>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socklen_t addrlen);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>Once you've built a socket descriptor with the <tt>socket()</tt>
call, you can <tt>connect()</tt> that socket to a remote server
using the well-named <tt>connect()</tt> system call.  All you need
to do is pass it the socket descriptor and the address of the server
you're interested in getting to know better.  (Oh, and the length of the
address, which is commonly passed to functions like this.)</p>

<p>If you haven't yet called <tt>bind()</tt> on the socket
descriptor, it is automatically bound to your IP address and a random
local port.  This is usually just fine with you, since you really don't
care what your local port is; you only care what the remote port is so
you can put it in the <b><tt>serv_addr</tt></b> parameter.  You
<i>can</i> call <tt>bind()</tt> if you really want your client
socket to be on a specific IP address and port, but this is pretty
rare.</p>

<p>Once the socket is <tt>connect()</tt>ed, you're free to
<tt>send()</tt> and <tt>recv()</tt> data on it to your heart's
content.</p>

<p>Special note: if you <tt>connect()</tt> a
<b><tt>SOCK_DGRAM</tt></b> UDP socket to a remote host, you can use
<tt>send()</tt> and <tt>recv()</tt> as well as
<tt>sendto()</tt> and <tt>recvfrom()</tt>.  If you want.</p>

</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p>Returns zero on success, or <b><tt>-1</tt></b> on error (and
<tt>errno</tt> will be set accordingly.)</p>
</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int s;
struct sockaddr_in serv_addr;

// pretend the server is at 63.161.169.137 listening on port 80:

myaddr.sin_family = AF_INET;
myaddr.sin_port = htons(80);
inet_aton("63.161.169.137", &amp;myaddr.sin_addr.s_addr);

s = socket(PF_INET, SOCK_STREAM, 0);
connect(s, (struct sockaddr*)myaddr, sizeof(myaddr));

// now we're ready to send() and recv()
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#socketman"><tt>socket()</tt></a>,
<a href="#bindman"><tt>bind()</tt></a></p>
</dd></dl>




<!--  ================================================================
== close()
=================================================================  -->


<p><hr/>
<h2><a name="closeman"><tt>close()</tt></a></h2></p>

<p>Close a socket descriptor</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;unistd.h&gt;</tt></p>
<p><tt>int close(int s);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>After you've finished using the socket for whatever demented scheme
you have concocted and you don't want to <tt>send()</tt> or
<tt>recv()</tt> or, indeed, do <i>anything else</i> at all with
the socket, you can <tt>close()</tt> it, and it'll be freed up,
never to be used again.</p>

<p>The remote side can tell if this happens one of two ways. One: if the
remote side calls <tt>recv()</tt>, it will return <b><tt>0</tt></b>.
Two: if the remote side calls <tt>send()</tt>, it'll recieve a
signal <b><tt>SIGPIPE</tt></b> and send() will return <b><tt>-1</tt></b>
and <b><tt>errno</tt></b> will be set to <b><tt>EPIPE</tt></b>.</p>

<p><b>Windows users</b>: the function you need to use is called
<tt>closesocket()</tt>, not <tt>close()</tt>.  If you try to use
<tt>close()</tt> on a socket descriptor, it's possible Windows will
get angry... And you wouldn't like it when it's angry.</p>

</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p>Returns zero on success, or <b><tt>-1</tt></b> on error (and
<tt>errno</tt> will be set accordingly.)</p>
</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
s = socket(PF_INET, SOCK_DGRAM, 0);
.
.
.
// a whole lotta stuff...*BRRRONNNN!*
.
.
.
close(s);  // not much to it, really.
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#socketman"><tt>socket()</tt></a>,
<a href="#shutdownman"><tt>shutdown()</tt></a></p>
</dd></dl>




<!--  ================================================================
== gethostname()
=================================================================  -->


<p><hr/>
<h2><a name="gethostnameman"><tt>gethostname()</tt></a></h2></p>

<p>Returns the name of the system</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;sys/unistd.h&gt;</tt></p>
<p><tt>int gethostname(char *name, size_t len);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>Your system has a name.  They all do.  This is a slightly more Unixy
thing than the rest of the networky stuff we've been talking about, but
it still has its uses.</p>

<p>For instance, you can get your host name, and then call
<tt>gethostbyname()</tt> to find out your IP address.</p>

<p>The parameter <b><tt>name</tt></b> should point to a buffer that will hold
the host name, and <b><tt>len</tt></b> is the size of that buffer in bytes.
<tt>gethostname()</tt> won't overwrite the end of the buffer (it
might return an error, or it might just stop writing), and it will
<b><tt>NUL</tt></b>-terminate the string if there's room for it in the
buffer.</p>
</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p>Returns zero on success, or <b><tt>-1</tt></b> on error (and
<tt>errno</tt> will be set accordingly.)</p>
</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
char hostname[128];

gethostname(hostname, sizeof(hostname));
printf("My hostname: %s\n", hostname);
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#gethostbynameman"><tt>gethostbyname()</tt></a></p>
</dd></dl>




<!--  ================================================================
== gethostbyname(), gethostbyaddr()
=================================================================  -->


<p><hr/>
<h2><a name="gethostbynameman"><tt>gethostbyname()</tt>, <tt>gethostbyaddr()</tt></a></h2></p>

<p>Get an IP address for a hostname, or vice-versa</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;sys/socket.h&gt;</tt><br/>
<tt>#include &lt;netdb.h&gt;</tt></p>
<p><tt>struct hostent *gethostbyname(const char *name);</tt><br/>
<tt>struct hostent *gethostbyaddr(const char *addr, int len, int type);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>These functions map back and forth between host names and IP
addresses.  After all, you want an IP address to pass to
<tt>connect()</tt>, right?  But no one wants to remember an IP
address.  So you let your users type in things like "www.yahoo.com"
instead of "66.94.230.35".</p>

<p><tt>gethostbyname()</tt> takes a string like "www.yahoo.com", and
returns a <tt>struct hostent</tt> which contains tons of
information, including the IP address.  (Other information is the
official host name, a list of aliases, the address type, the length of
the addresses, and the list of addresses--it's a general-purpose
structure that's pretty easy to use for our specific purposes once you
see how.)</p>

<p><tt>gethostbyaddr()</tt> takes a <tt>struct in_addr</tt> and brings
you up a corresponding host name (if there is one), so it's sort of the
reverse of <tt>gethostbyname()</tt>.  As for parameters, even though
<b><tt>addr</tt></b> is a <tt>char*</tt>, you actually want to pass in a
pointer to a <tt>struct in_addr</tt>.  <b><tt>len</tt></b> should be
<tt>sizeof(struct in_addr)</tt>, and <b><tt>type</tt></b> should be
<b><tt>AF_INET</tt></b>.</p>

<p>So what is this <tt>struct hostent</tt> that gets returned?  It
has a number of fields that contain information about the host in
question.</p>

<p><table cellpadding="10" cellspacing="0" border="0">

<tr><td valign="top" align="left" width="30%"><p><b><tt>char *h_name</tt></b></p></td>

<td valign="top" align="left" width="68%"><p>The real canonical host name.</p></td>
</tr>


<tr><td valign="top" align="left" width="30%"><p><b><tt>char **h_aliases</tt></b></p></td>

<td valign="top" align="left" width="68%"><p>A list of aliases that can be accessed with
arrays--the last element is <b><tt>NULL</tt></b></p></td>
</tr>


<tr><td valign="top" align="left" width="30%"><p><b><tt>int h_addrtype</tt></b></p></td>

<td valign="top" align="left" width="68%"><p>The result's address type, which really should be
<b><tt>AF_INET</tt></b> for our purposes..</p></td>
</tr>


<tr><td valign="top" align="left" width="30%"><p><b><tt>int length</tt></b></p></td>

<td valign="top" align="left" width="68%"><p>The length of the addresses in bytes, which is 4 for
IP (version 4) addresses.</p></td>
</tr>


<tr><td valign="top" align="left" width="30%"><p><b><tt>char **h_addr_list</tt></b></p></td>

<td valign="top" align="left" width="68%"><p>A list of IP addresses for this host.  Although this
is a <tt>char**</tt>, it's really an array of <tt>struct
in_addr*</tt>s in disguise.  The last array element is
<b><tt>NULL</tt></b>.</p></td>
</tr>


<tr><td valign="top" align="left" width="30%"><p><b><tt>h_addr</tt></b></p></td>

<td valign="top" align="left" width="68%"><p>A commonly defined alias for
<b><tt>h_addr_list[0]</tt></b>.  If you just want any old IP address for this
host (yeah, they can have more than one) just use this field.</p></td>
</tr>


</table>
</p>

</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p>Returns a pointer to a resultant <tt>struct hostent</tt> or
success, or <b><tt>NULL</tt></b> on error.</p>

<p>Instead of the normal <tt>perror()</tt> and all that stuff you'd
normally use for error reporting, these functions have parallel results
in the variable <b><tt>h_errno</tt></b>, which can be printed using the
functions <tt>herror()</tt> or <tt>hstrerror()</tt>.  These work
just like the classic <b><tt>errno</tt></b>, <tt>perror()</tt>, and
<tt>strerror()</tt> functions you're used to.</p>

</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int i;
struct hostent *he;
struct in_addr **addr_list;
struct in_addr addr;

// get the addresses of www.yahoo.com:

he = gethostbyname("www.yahoo.com");
if (he == NULL) { // do some error checking
    herror("gethostbyname"); // herror(), NOT perror()
    exit(1);
}

// print information about this host:
printf("Official name is: %s\n", he-&gt;h_name);
printf("IP address: %s\n", inet_ntoa(*(struct in_addr*)he-&gt;h_addr));
printf("All addresses: ");
addr_list = (struct in_addr **)he-&gt;h_addr_list;
for(i = 0; addr_list[i] != NULL; i++) {
    printf("%s ", inet_ntoa(*addr_list[i]));
}
printf("\n");

// get the host name of 66.94.230.32:

inet_aton("66.94.230.32", &amp;addr);
he = gethostbyaddr(&amp;addr, sizeof(addr), AF_INET);

printf("Host name: %s\n", he-&gt;h_name);
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#gethostnameman"><tt>gethostname()</tt></a>,
<a href="#errnoman"><b><tt>errno</tt></b></a>,
<a href="#perrorman"><tt>perror()</tt></a>,
<a href="#perrorman"><tt>strerror()</tt></a>,
<a href="#sockaddr_inman"><tt>struct in_addr</tt></a></p>
</dd></dl>




<!--  ================================================================
== getpeername()
=================================================================  -->


<p><hr/>
<h2><a name="getpeernameman"><tt>getpeername()</tt></a></h2></p>

<p>Return address info about the remote side of the connection</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;sys/socket.h&gt;</tt></p>
<p><tt>int getpeername(int s, struct sockaddr *addr, socklen_t
*len);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>Once you have either <tt>accept()</tt>ed a remote connection, or
<tt>connect()</tt>ed to a server, you now have what is known as a
<i>peer</i>.  Your peer is simply the computer you're connected to,
identified by an IP address and a port.  So...</p>

<p><tt>getpeername()</tt> simply returns a <tt>struct
sockaddr_in</tt> filled with information about the machine you're
connected to.</p>

<p>Why is it called a "name"?  Well, there are a lot of different kinds
of sockets, not just Internet Sockets like we're using in this guide,
and so "name" was a nice generic term that covered all cases.  In our
case, though, the peer's "name" is it's IP address and port.</p>

<p>Although the function returns the size of the resultant address in
<b><tt>len</tt></b>, you must preload <b><tt>len</tt></b> with the size of
<b><tt>addr</tt></b>.</p>

</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p>Returns zero on success, or <b><tt>-1</tt></b> on error (and
<tt>errno</tt> will be set accordingly.)</p>
</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int s;
struct sockaddr_in server, addr;
socklen_t len;

// make a socket
s = socket(PF_INET, SOCK_STREAM, 0);

// connect to a server
server.sin_family = AF_INET;
inet_aton("63.161.169.137", &amp;server.sin_addr);
server.sin_port = htons(80);

connect(s, (struct sockaddr*)&amp;server, sizeof(server));

// get the peer name
// we know we just connected to 63.161.169.137:80, so this should print:
//    Peer IP address: 63.161.169.137
//    Peer port      : 80

len = sizeof(addr);
getpeername(s, (struct sockaddr*)&amp;addr, &amp;len);
printf("Peer IP address: %s\n", inet_ntoa(addr.sin_addr));
printf("Peer port      : %d\n", ntohs(addr.sin_port));
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#gethostnameman"><tt>gethostname()</tt></a>,
<a href="#gethostbynameman"><tt>gethostbyname()</tt></a>,
<a href="#gethostbynameman"><tt>gethostbyaddr()</tt></a></p>
</dd></dl>


 

<!--  ================================================================
== errno
=================================================================  -->


<p><hr/>
<h2><a name="errnoman"><b><tt>errno</tt></b></a></h2></p>

<p>Holds the error code for the last system call</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;errno.h&gt;</tt></p>
<p><tt>int errno;</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>This is the variable that holds error information for a lot of
system calls.  If you'll recall, things like <tt>socket()</tt> and
<tt>listen()</tt> return <b><tt>-1</tt></b> on error, and they set
the exact value of <b><tt>errno</tt></b> to let you know specifically which
error occurred.</p>

<p>The header file <i><tt>errno.h</tt></i> lists a bunch of constant
symbolic names for errors, such as <b><tt>EADDRINUSE</tt></b>,
<b><tt>EPIPE</tt></b>, <b><tt>ECONNREFUSED</tt></b>, etc.  Your local man
pages will tell you what codes can be returned as an error, and you can
use these at run time to handle different errors in different ways.</p>

<p>Or, more commonly, you can call <tt>perror()</tt> or
<tt>strerror()</tt> to get a human-readable version of the
error.</p>
</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p>The value of the variable is the latest error to have transpired, which
might be the code for "success" if the last action succeeded.</p>
</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
s = socket(PF_INET, SOCK_STREAM, 0);
if (s == -1) {
    perror("socket"); // or use strerror()
}

tryagain:
if (select(n, &amp;readfds, NULL, NULL) == -1) {
    // an error has occurred!!

    // if we were only interrupted, just restart the select() call:
    if (errno == EINTR) goto tryagain;  // AAAA!  goto!!!

    // otherwise it's a more serious error:
    perror("select");
    exit(1);
}
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#perrorman"><tt>perror()</tt></a>,
<a href="#perrorman"><tt>strerror()</tt></a></p>
</dd></dl>




<!--  ================================================================
== fcntl()
=================================================================  -->


<p><hr/>
<h2><a name="fcntlman"><tt>fcntl()</tt></a></h2></p>

<p>Control socket descriptors</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;sys/unistd.h&gt;</tt><br/>
<tt>#include &lt;sys/fcntl.h&gt;</tt></p>
<p><tt>int fcntl(int s, int cmd, long arg);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>This function is typically used to do file locking and other
file-oriented stuff, but it also has a couple socket-related functions
that you might see or use from time to time.</p>

<p>Parameter <b><tt>s</tt></b> is the socket descriptor you wish to operate
on, <b><tt>cmd</tt></b> should be set to <b><tt>F_SETFL</tt></b>, and
<b><tt>arg</tt></b> can be one of the following commands.  (Like I said,
there's more to <tt>fcntl()</tt> than I'm letting on here, but I'm
trying to stay socket-oriented.)</p>

<p><table cellpadding="10" cellspacing="0" border="0">

<tr><td valign="top" align="left" width="20%"><p><b><tt>O_NONBLOCK</tt></b></p></td>

<td valign="top" align="left" width="73%"><p>Set the socket to be non-blocking.  See the section on
<a href="#blocking">blocking</a> for more details.</p></td>
</tr>


<tr><td valign="top" align="left" width="20%"><p><b><tt>O_ASYNC</tt></b></p></td>

<td valign="top" align="left" width="73%"><p>Set the socket to do asynchronous I/O.  When data is
ready to be <tt>recv()</tt>'d on the socket, the signal
<b><tt>SIGIO</tt></b> will be raised.  This is rare to see, and beyond
the scope of the guide.  And I think it's only available on certain
systems.</p></td>
</tr>


</table>
</p>

</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p>Returns zero on success, or <b><tt>-1</tt></b> on error (and
<tt>errno</tt> will be set accordingly.)</p>

<p>Different uses of the <tt>fcntl()</tt> actually have
different return values, but I haven't covered them here because they're
not socket-related.  See your local <tt>fcntl()</tt> man page for
more information.</p>
</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int s = socket(PF_INET, SOCK_STREAM, 0);

fcntl(s, F_SETFL, O_NONBLOCK);  // set to non-blocking
fcntl(s, F_SETFL, O_ASYNC);     // set to asynchronous I/O
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#blocking">Blocking</a>,
<a href="#sendman"><tt>send()</tt></a></p>
</dd></dl>




<!--  ================================================================
== htons, htonl, ntohs, ntohl
=================================================================  -->


<p><hr/>
<h2><a name="htonsman"><tt>htons()</tt>, <tt>htonl()</tt>,
<tt>ntohs()</tt>, <tt>ntohl()</tt></a></h2></p>


<p>Convert multi-byte integer types from host byte order to
network byte order</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;netinet/in.h&gt;</tt></p>
<p><tt>uint32_t htonl(uint32_t hostlong);</tt><br/>
<tt>uint16_t htons(uint16_t hostshort);</tt><br/>
<tt>uint32_t ntohl(uint32_t netlong);</tt><br/>
<tt>uint16_t ntohs(uint16_t netshort);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>Just to make you really unhappy, different computers use different
byte orderings internally for their multibyte integers (i.e. any
interger that's larger than a <tt>char</tt>.)  The upshot of this is
that if you <tt>send()</tt> a two-byte <tt>short int</tt> from
an Intel box to a Mac (before they became Intel boxes, too, I mean),
what one computer thinks is the number <b><tt>1</tt></b>, the other will
think is the number <b><tt>256</tt></b>, and vice-versa.</p>

<p>The way to get around this problem is for everyone to put aside their
differences and agree that Motorola and IBM had it right, and Intel did
it the weird way, and so we all convert our byte orderings to
"big-endian" before sending them out.  Since Intel is a "little-endian"
machine, it's far more politically correct to call our preferred byte
ordering "Network Byte Order".  So these functions convert from your
native byte order to network byte order and back again.</p>

<p>(This means on Intel these functions swap all the bytes around, and
on PowerPC they do nothing because the bytes are already in Network
Byte Order.  But you should always use them in your code anyway, since
someone might want to build it on an Intel machine and still have things
work properly.)</p>

<p>Note that the types involved are 32-bit (4 byte, probably
<tt>int</tt>) and 16-bit (2 byte, very likely <tt>short</tt>)
numbers.  64-bit machines might have a <tt>htonll()</tt> for 64-bit
ints, but I've not seen it.  You'll just have to write your own.</p>

<p>Anyway, the way these functions work is that you first decide if
you're converting <i>from</i> host (your machine's) byte order or
from network byte order.  If "host", the the first letter of the
function you're going to call is "h".  Otherwise it's "n" for "network".
The middle of the function name is always "to" because you're converting
from one "to" another, and the penultimate letter shows what you're converting
<i>to</i>.  The last letter is the size of the data, "s" for short,
or "l" for long.  Thus:</p>

<p><table cellpadding="10" cellspacing="0" border="0">

<tr><td valign="top" align="left" width="15%"><p><tt>htons()</tt></p></td>

<td valign="top" align="left" width="78%"><p><i>h</i>ost <i>to</i> <i>n</i>etwork
<i>s</i>hort</p></td>
</tr>


<tr><td valign="top" align="left" width="15%"><p><tt>htonl()</tt></p></td>

<td valign="top" align="left" width="78%"><p><i>h</i>ost <i>to</i> <i>n</i>etwork
<i>l</i>ong</p></td>
</tr>


<tr><td valign="top" align="left" width="15%"><p><tt>ntohs()</tt></p></td>

<td valign="top" align="left" width="78%"><p><i>n</i>etwork <i>to</i> <i>h</i>ost
<i>s</i>hort</p></td>
</tr>


<tr><td valign="top" align="left" width="15%"><p><tt>ntohl()</tt></p></td>

<td valign="top" align="left" width="78%"><p><i>n</i>etwork <i>to</i> <i>h</i>ost
<i>l</i>ong</p></td>
</tr>

</table>
</p>

</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p>Each function returns the converted value.</p>
</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
uint32_t some_long = 10;
uint16_t some_short = 20;

uint32_t network_byte_order;

// convert and send
network_byte_order = htonl(some_long);
send(s, &amp;network_byte_order, sizeof(uint32_t), 0);

some_short == ntohs(htons(some_short)); // this expression is true
</pre>
</table></p>

</dd></dl>


<!-- 
<seealso>
</seealso>
 -->



<!--  ================================================================
== inet_ntoa() etc
=================================================================  -->


<p><hr/>
<h2><a name="inet_ntoaman"><tt>inet_ntoa()</tt>, <tt>inet_aton()</tt></a></h2></p>

<p>Convert IP addresses from a dots-and-number string to a
<tt>struct in_addr</tt> and back</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;sys/socket.h&gt;</tt><br/>
<tt>#include &lt;netinet/in.h&gt;</tt><br/>
<tt>#include &lt;arpa/inet.h&gt;</tt></p>
<p><tt>char *inet_ntoa(struct in_addr in);</tt><br/>
<tt>int inet_aton(const char *cp, struct in_addr *inp);</tt><br/>
<tt>in_addr_t inet_addr(const char *cp);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>All of these functions convert from a <tt>struct in_addr</tt>
(part of your <tt>struct sockaddr_in</tt>, most likely) to a string
in dots-and-numbers format (e.g. "192.168.5.10") and vice-versa.  If you
have an IP address passed on the command line or something, this is the
easiest way to get a <tt>struct in_addr</tt> to
<tt>connect()</tt> to, or whatever.  If you need more power, try
some of the DNS functions like <tt>gethostbyname()</tt> or attempt a
coup-de-tat in your local country.</p>

<p>The function <tt>inet_ntoa()</tt> converts a network address in a
<tt>struct in_addr</tt> to a dots-and-numbers format string.  The
"n" in "ntoa" stands for network, and the "a" stands for ASCII for
historical reasons (so it's "Network To ASCII"--the "toa" suffix has an
analogous friend in the C library called <tt>atoi()</tt> which
converts an ASCII string to an integer.)</p>

<p>The function <tt>inet_aton()</tt> is the opposite, converting
from a dots-and-numbers string into a <tt>in_addr_t</tt> (which is
the type of the field <tt>s_addr</tt> in your <tt>struct
in_addr</tt>.)</p>

<p>Finally, the function <tt>inet_addr()</tt> is an older function
that does basically the same thing as <tt>inet_aton()</tt>.  It's
theoretically deprecated, but you'll see it alot and the police won't
come get you if you use it.</p>

</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p><tt>inet_aton()</tt> returns non-zero if the address is a valid
one, and it returns zero if the address is invalid.</p>

<p><tt>inet_ntoa()</tt> returns the dots-and-numbers string in a
static buffer that is overwritten with each call to the function.</p>

<p><tt>inet_addr()</tt> returns the address as an
<tt>in_addr_t</tt>, or <b><tt>-1</tt></b> if there's an error.  (That
is the same result as if you tried to convert the string
"255.255.255.255", which is a valid IP address.  This is why
<tt>inet_aton()</tt> is better.)</p>

</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
struct sockaddr_in antelope;
char *some_addr;

inet_aton("10.0.0.1", &amp;antelope.sin_addr); // store IP in antelope

some_addr = inet_ntoa(antelope.sin_addr); // return the IP
printf("%s\n", some_addr); // prints "10.0.0.1"

// and this call is the same as the inet_aton() call, above:
antelope.sin_addr.s_addr = inet_addr("10.0.0.1");
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#gethostbynameman"><tt>gethostbyname()</tt></a>,
<a href="#gethostbynameman"><tt>gethostbyaddr()</tt></a></p>
</dd></dl>




<!--  ================================================================
== listen()
=================================================================  -->


<p><hr/>
<h2><a name="listenman"><tt>listen()</tt></a></h2></p>

<p>Tell a socket to listen for incoming connections</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;sys/socket.h&gt;</tt></p>
<p><tt>int listen(int s, int backlog);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>You can take your socket descriptor (made with the <tt>socket()</tt>
system call) and tell it to listen for incoming connections.  This is
what differentiates the servers from the clients, guys.</p>

<p>The <b><tt>backlog</tt></b> parameter can mean a couple different things
depending on the system you on, but loosely it is how many pending
connections you can have before the kernel starts rejecting new ones.
So as the new connections come in, you should be quick to
<tt>accept()</tt> them so that the backlog doesn't fill.  Try
setting it to 10 or so, and if your clients start getting "Connection
refused" under heavy load, set it higher.</p>

<p>Before calling <tt>listen()</tt>, your server should call
<tt>bind()</tt> to attach itself to a specific port number.  That
port number (on the server's IP address) will be the one that clients
connect to.</p>

</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p>Returns zero on success, or <b><tt>-1</tt></b> on error (and
<tt>errno</tt> will be set accordingly.)</p>
</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int s;
struct sockaddr_in myaddr;

myaddr.sin_family = AF_INET;
myaddr.sin_port = htons(3490); // clients connect to this port
myaddr.sin_addr.s_addr = INADDR_ANY; // autoselect IP address

s = socket(PF_INET, SOCK_STREAM, 0);
bind(s, (struct sockaddr*)myaddr, sizeof(myaddr));

listen(s, 10); // set s up to be a server (listening) socket

// then have an accept() loop down here somewhere
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#acceptman"><tt>accept()</tt></a>,
<a href="#bindman"><tt>bind()</tt></a>,
<a href="#socketman"><tt>socket()</tt></a></p>
</dd></dl>




<!--  ================================================================
== perror()
=================================================================  -->


<p><hr/>
<h2><a name="perrorman"><tt>perror()</tt>, <tt>strerror()</tt></a></h2></p>

<p>Print an error as a human-readable string</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;stdio.h&gt;</tt></p>
<p><tt>void perror(const char *s);</tt></p>
<p><tt>#include &lt;string.h&gt;</tt></p>
<p><tt>char *strerror(int errnum);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>

<p>Since so many functions return <b><tt>-1</tt></b> on error and set the
value of the variable <b><tt>errno</tt></b> to be some number, it would sure
be nice if you could easily print that in a form that made sense to
you.</p>

<p>Mercifully, <tt>perror()</tt> does that.  If you want more
description to be printed before the error, you can point the parameter
<b><tt>s</tt></b> to it (or you can leave <b><tt>s</tt></b> as <b><tt>NULL</tt></b>
and nothing additional will be printed.)</p>

<p>In a nutshell, this function takes <b><tt>errno</tt></b> values, like
<b><tt>ECONNRESET</tt></b>, and prints them nicely, like "Connection
reset by peer."</p>

<p>The function <tt>strerror()</tt> is very similar to
<tt>perror()</tt>, except it returns a pointer to the error message
string for a given value (you usually pass in the variable
<b><tt>errno</tt></b>.)</p>

</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p><tt>strerror()</tt> returns a pointer to the error message
string.</p>
</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int s;

s = socket(PF_INET, SOCK_STREAM, 0);

if (s == -1) { // some error has occurred
    // prints "socket error: " + the error message:
    perror("socket error");
}

// similarly:
if (listen(s, 10) == -1) {
    // this prints "an error: " + the error message from errno:
    printf("an error: %s\n", strerror(errno));
}
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#errnoman"><b><tt>errno</tt></b></a></p>
</dd></dl>




<!--  ================================================================
== poll
=================================================================  -->


<p><hr/>
<h2><a name="pollman"><tt>poll()</tt></a></h2></p>

<p>Test for events on multiple sockets simultaneously</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;sys/poll.h&gt;</tt></p>
<p><tt>int poll(struct pollfd *ufds, unsigned int nfds, int
timeout);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>This function is very similar to <tt>select()</tt> in that they
both watch sets of file descriptors for events, such as incoming data
ready to <tt>recv()</tt>, socket ready to <tt>send()</tt> data
to, out-of-band data ready to <tt>recv()</tt>, errors, etc.</p>

<p>The basic idea is that you pass an array of <b><tt>nfds</tt></b>
<tt>struct pollfd</tt>s in <b><tt>ufds</tt></b>, along with a timeout in
milliseconds (1000 milliseconds in a second.)  The <b><tt>timeout</tt></b>
can be negative if you want to wait forever.  If no event happen on any
of the socket descriptors by the timeout, <tt>poll()</tt> will
return.</p>

<p>Each element in the array of <tt>struct pollfd</tt>s represents
one socket descriptor, and contains the following fields:</p>

<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
struct pollfd {
    int fd;         // the socket descriptor
    short events;   // bitmap of events we're interested in
    short revents;  // when poll() returns, bitmap of events that occurred
};
</pre>
</table></p>


<p>Before calling <tt>poll()</tt>, load <b><tt>fd</tt></b> with the
socket descriptor (if you set <b><tt>fd</tt></b> to a negative number, this
<tt>struct pollfd</tt> is ignored and its <b><tt>revents</tt></b> field
is set to zero) and then construct the <b><tt>events</tt></b> field by
bitwise-ORing the following macros:</p>

<p><table cellpadding="10" cellspacing="0" border="0">

<tr><td valign="top" align="left" width="25%"><p><b><tt>POLLIN</tt></b></p></td>

<td valign="top" align="left" width="73%"><p>Alert me when data is ready to
<tt>recv()</tt> on this socket.</p></td>
</tr>


<tr><td valign="top" align="left" width="25%"><p><b><tt>POLLOUT</tt></b></p></td>

<td valign="top" align="left" width="73%"><p>Alert me when I can <tt>send()</tt> data to this
socket without blocking.</p></td>
</tr>


<tr><td valign="top" align="left" width="25%"><p><b><tt>POLLPRI</tt></b></p></td>

<td valign="top" align="left" width="73%"><p>Alert me when out-of-band data is ready to
<tt>recv()</tt> on this socket.</p></td>
</tr>

</table>
</p>

<p>Once the <tt>poll()</tt> call returns, the <b><tt>revents</tt></b>
field will be constructed as a bitwise-OR of the above fields, telling
you which descriptors actually have had that event occur.  Additionally,
these other fields might be present:</p>

<p><table cellpadding="10" cellspacing="0" border="0">

<tr><td valign="top" align="left" width="25%"><p><b><tt>POLLERR</tt></b></p></td>

<td valign="top" align="left" width="73%"><p>An error has occurred on this socket.</p></td>
</tr>


<tr><td valign="top" align="left" width="25%"><p><b><tt>POLLHUP</tt></b></p></td>

<td valign="top" align="left" width="73%"><p>The remote side of the connection hung up.</p></td>
</tr>


<tr><td valign="top" align="left" width="25%"><p><b><tt>POLLNVAL</tt></b></p></td>

<td valign="top" align="left" width="73%"><p>Something was wrong with the socket descriptor
<b><tt>fd</tt></b>--maybe it's uninitialized?</p></td>
</tr>

</table>
</p>

</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p>Returns the number of elements in the <b><tt>ufds</tt></b> array that have
had event occur on them; this can be zero if the timeout occurred.  Also
returns <b><tt>-1</tt></b> on error (and <tt>errno</tt> will be set
accordingly.)</p>
</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int s1, s2;
int rv;
char buf1[256], buf2[256];
struct pollfd ufds[2];

s1 = socket(PF_INET, SOCK_STREAM, 0);
s2 = socket(PF_INET, SOCK_STREAM, 0);

// pretend we've connected both to a server at this point
//connect(s1, ...)...
//connect(s2, ...)...

// set up the array of file descriptors.
//
// in this example, we want to know when there's normal or out-of-band
// data ready to be recv()'d...

ufds[0].fd = s1;
ufds[0].events = POLLIN | POLLPRI; // check for normal or out-of-band

ufds[1] = s2;
ufds[1].events = POLLIN; // check for just normal data

// wait for events on the sockets, 3.5 second timeout
rv = poll(ufds, 2, 3500);

if (rv == -1) {
    perror("poll"); // error occurred in poll()
} else if (rv == 0) {
    printf("Timeout occurred!  No data after 3.5 seconds.\n");
} else {
    // check for events on s1:
    if (ufds[0].revents &amp; POLLIN) {
        recv(s1, buf1, sizeof(buf1), 0); // receive normal data
    }
    if (ufds[0].revents &amp; POLLPRI) {
        recv(s1, buf1, sizeof(buf1), MSG_OOB); // out-of-band data
    }

    // check for events on s2:
    if (ufds[1].revents &amp; POLLIN) {
        recv(s1, buf2, sizeof(buf2), 0);
    }
}
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#selectman"><tt>select()</tt></a></p>
</dd></dl>




<!--  ================================================================
== recv(), recvfrom()
=================================================================  -->


<p><hr/>
<h2><a name="recvman"><tt>recv()</tt>, <tt>recvfrom()</tt></a></h2></p>

<p>Recieve data on a socket</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;sys/types.h&gt;</tt><br/>
<tt>#include &lt;sys/socket.h&gt;</tt></p>
<p><tt>ssize_t recv(int s, void *buf, size_t len, int flags);</tt><br/>
<tt>ssize_t recvfrom(int s, void *buf, size_t len, int flags,</tt><br/>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct sockaddr *from, socklen_t *fromlen);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>Once you have a socket up and connected, you can read incoming data
from the remote side using the <tt>recv()</tt> (for TCP
<b><tt>SOCK_STREAM</tt></b> sockets) and <tt>recvfrom()</tt> (for UDP
<b><tt>SOCK_DGRAM</tt></b> sockets).</p>

<p>Both functions take the socket descriptor <b><tt>s</tt></b>, a pointer to
the buffer <b><tt>buf</tt></b>, the size (in bytes) of the buffer
<b><tt>len</tt></b>, and a set of <b><tt>flags</tt></b> that control how the
functions work.</p>

<p>Additionally, the <tt>recvfrom()</tt> takes a <tt>struct
sockaddr*</tt>, <b><tt>from</tt></b> that will tell you where the data came
from, and will fill in <b><tt>fromlen</tt></b> with the size of <tt>struct
sockaddr</tt>.  (You must also initialize <b><tt>fromlen</tt></b> to be the
size of <b><tt>from</tt></b> or <tt>struct sockaddr</tt>.)</p>

<p>So what wonderous flags can you pass into this function?  Here are
some of them, but you should check your local man pages for more
information and what is actually supported on your system.  You
bitwise-or these together, or just set <b><tt>flags</tt></b> to
<b><tt>0</tt></b> if you want it to be a regular vanilla
<tt>recv()</tt>.</p>

<p><table cellpadding="10" cellspacing="0" border="0">

<tr><td valign="top" align="left" width="30%"><p><b><tt>MSG_OOB</tt></b></p></td>

<td valign="top" align="left" width="68%"><p>Recieve Out of Band data.  This is how to get data that
has been sent to you with the <b><tt>MSG_OOB</tt></b> flag in
<tt>send()</tt>.  As the recieving side, you will have had signal
<b><tt>SIGURG</tt></b> raised telling you there is urgent data.  In your
handler for that signal, you could call <tt>recv()</tt> with this
<b><tt>MSG_OOB</tt></b> flag.</p></td>
</tr>


<tr><td valign="top" align="left" width="30%"><p><b><tt>MSG_PEEK</tt></b></p></td>

<td valign="top" align="left" width="68%"><p>If you want to call <tt>recv()</tt> "just for
pretend", you can call it with this flag.  This will tell you what's
waiting in the buffer for when you call <tt>recv()</tt> "for real"
(i.e. <i>without</i> the <b><tt>MSG_PEEK</tt></b> flag.  It's like a
sneak preview into the next <tt>recv()</tt> call.</p></td>
</tr>


<tr><td valign="top" align="left" width="30%"><p><b><tt>MSG_WAITALL</tt></b></p></td>

<td valign="top" align="left" width="68%"><p>Tell <tt>recv()</tt> to not return until all the data
you specified in the <b><tt>len</tt></b> parameter.  It will ignore your
wishes in extreme circumstances, however, like if a signal interrupts
the call or if some error occurs or if the remote side closes the
connection, etc.  Don't be mad with it.</p></td>
</tr>


</table>
</p>

<p>When you call <tt>recv()</tt>, it will block until there is some
data to read.  If you want to not block, set the socket to non-blocking
or check with <tt>select()</tt> or <tt>poll()</tt> to see if
there is incoming data before calling <tt>recv()</tt> or
<tt>recvfrom()</tt>.</p>

</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p>Returns the number of bytes actually recieved (which might be less
than you requested in the <b><tt>len</tt></b> paramter), or <b><tt>-1</tt></b>
on error (and <tt>errno</tt> will be set accordingly.)</p>

<p>If the remote side has closed the connection, <tt>recv()</tt>
will return <b><tt>0</tt></b>.  This is the normal method for determining
if the remote side has closed the connection.  Normality is good,
rebel!</p>

</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int s1, s2;
int byte_count, fromlen;
struct sockaddr_in addr;
char buf[512];

// show example with a TCP stream socket first
s1 = socket(PF_INET, SOCK_STREAM, 0);

// info about the server
addr.sin_family = AF_INET;
addr.sin_port = htons(3490);
inet_aton("10.9.8.7", &amp;addr.sin_addr);

connect(s1, &amp;addr, sizeof(addr)); // connect to server

// all right!  now that we're connected, we can recieve some data!
byte_count = recv(s1, buf, sizeof(buf), 0);
printf("recv()'d %d bytes of data in buf\n", byte_count);

// now demo for UDP datagram sockets:
s2 = socket(PF_INET, SOCK_DGRAM, 0);

fromlen = sizeof(addr);
byte_count = recvfrom(s2, buf, sizeof(buf), 0, &amp;addr, &amp;fromlen);
printf("recv()'d %d bytes of data in buf\n", byte_count);
printf("from IP address %s\n", inet_ntoa(addr.sin_addr));
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#sendman"><tt>send()</tt></a>,
<a href="#sendman"><tt>sendto()</tt></a>,
<a href="#selectman"><tt>select()</tt></a>,
<a href="#pollman"><tt>poll()</tt></a>,
<a href="#blocking">Blocking</a></p>
</dd></dl>




<!--  ================================================================
== select()
=================================================================  -->


<p><hr/>
<h2><a name="selectman"><tt>select()</tt></a></h2></p>

<p>Check if sockets descriptors are ready to read/write</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;sys/select.h&gt;</tt></p>
<p><tt>int select(int n, fd_set *readfds, fd_set *writefds,</tt><br/>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fd_set *exceptfds, struct timeval *timeout);</tt><br/>
<tt>FD_SET(int fd, fd_set *set);</tt><br/>
<tt>FD_CLR(int fd, fd_set *set);</tt><br/>
<tt>FD_ISSET(int fd, fd_set *set);</tt><br/>
<tt>FD_ZERO(fd_set *set);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>The <tt>select()</tt> function gives you a way to simultaneously
check multiple sockets to see if they have data waiting to be
<tt>recv()</tt>d, or if you can <tt>send()</tt> data to them
without blocking, or if some exception has occurred.</p>

<p>You populate your sets of socket descriptors using the macros, like
<tt>FD_SET()</tt>, above.  Once you have the set, you pass it into
the function as one of the following parameters: <b><tt>readfds</tt></b> if
you want to know when any of the sockets in the set is ready to
<tt>recv()</tt> data, <b><tt>writefds</tt></b> if any of the sockets is
ready to <tt>send()</tt> data to, and/or <b><tt>exceptfds</tt></b> if you
need to know when an exception (error) occurs on any of the sockets.
Any or all of these parameters can be <b><tt>NULL</tt></b> if you're not
interested in those types of events.  After <tt>select()</tt>
returns, the values in the sets will be changed to show which are ready
for reading or writing, and which have exceptions.</p>

<p>The first parameter, <b><tt>n</tt></b> is the highest-numbered socket
descriptor (they're just <tt>int</tt>s, remember?) plus one.</p>

<p>Lastly, the <tt>struct timeval</tt>, <b><tt>timeout</tt></b>, at the
end--this lets you tell <tt>select()</tt> how long to check these
sets for.  It'll return after the timeout, or when an event occurs,
whichever is first.  The <tt>struct timeval</tt> has two fields:
<b><tt>tv_sec</tt></b> is the number of seconds, to which is added
<b><tt>tv_usec</tt></b>, the number of microseconds (1,000,000 microseconds
in a second.)</p>

<p>The helper macros do the following:</p>

<p><table cellpadding="10" cellspacing="0" border="0">

<tr><td valign="top" align="left" width="50%"><p><tt>FD_SET(int fd, fd_set *set);</tt></p></td>

<td valign="top" align="left" width="48%"><p>Add <b><tt>fd</tt></b> to the <b><tt>set</tt></b>.</p></td>
</tr>


<tr><td valign="top" align="left" width="50%"><p><tt>FD_CLR(int fd, fd_set *set);</tt></p></td>

<td valign="top" align="left" width="48%"><p>Remove <b><tt>fd</tt></b> from the <b><tt>set</tt></b>.</p></td>
</tr>


<tr><td valign="top" align="left" width="50%"><p><tt>FD_ISSET(int fd, fd_set *set);</tt></p></td>

<td valign="top" align="left" width="48%"><p>Return true if <b><tt>fd</tt></b> is in the
<b><tt>set</tt></b>.</p></td>
</tr>


<tr><td valign="top" align="left" width="50%"><p><tt>FD_ZERO(fd_set *set);</tt></p></td>

<td valign="top" align="left" width="48%"><p>Clear all entries from the <b><tt>set</tt></b>.</p></td>
</tr>

</table>
</p>

</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p>Returns the number of descriptors in the set on success,
<b><tt>0</tt></b> if the timeout was reached, or <b><tt>-1</tt></b> on
error (and <tt>errno</tt> will be set accordingly.)  Also, the sets
are modified to show which sockets are ready.</p>
</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int s1, s2, n;
fd_set readfds;
struct timeval tv;
char buf1[256], buf2[256];

s1 = socket(PF_INET, SOCK_STREAM, 0);
s2 = socket(PF_INET, SOCK_STREAM, 0);

// pretend we've connected both to a server at this point
//connect(s1, ...)...
//connect(s2, ...)...

// clear the set ahead of time
FD_ZERO(&amp;readfds);

// add our descriptors to the set
FD_SET(s1, &amp;readfds);
FD_SET(s2, &amp;readfds);

// since we got s2 second, it's the "greater", so we use that for
// the n param in select()
n = s2 + 1;

// wait until either socket has data ready to be recv()d (timeout 10.5 secs)
tv.tv_sec = 10;
tv.tv_usec = 500000;
rv = select(n, &amp;readfds, NULL, NULL, &amp;tv);

if (rv == -1) {
    perror("select"); // error occurred in select()
} else if (rv == 0) {
    printf("Timeout occurred!  No data after 10.5 seconds.\n");
} else {
    // one or both of the descriptors have data
    if (FD_ISSET(s1, &amp;readfds)) {
        recv(s1, buf1, sizeof(buf1), 0);
    }
    if (FD_ISSET(s2, &amp;readfds)) {
        recv(s1, buf2, sizeof(buf2), 0);
    }
}
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#pollman"><tt>poll()</tt></a></p>
</dd></dl>




<!--  ================================================================
== setsockopt()
=================================================================  -->


<p><hr/>
<h2><a name="setsockoptman"><tt>setsockopt()</tt>, <tt>getsockopt()</tt></a></h2></p>

<p>Set various options for a socket</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;sys/types.h&gt;</tt><br/>
<tt>#include &lt;sys/socket.h&gt;</tt></p>
<p><tt>int getsockopt(int s, int level, int optname, void *optval,</tt><br/>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socklen_t *optlen);</tt><br/>
<tt>int setsockopt(int s, int level, int optname, const void *optval,</tt><br/>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socklen_t optlen);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>Sockets are fairly configurable beasts.  In fact, they are so
configurable, I'm not even going to cover it all here.  It's probably
system-dependent anyway.  But I will talk about the basics.</p>

<p>Obviously, these functions get and set certain options on a socket.
On a Linux box, all the socket information is in the man page for socket
in section 7.  (Type: "<b><tt>man 7 socket</tt></b>" to get all these
goodies.)</p>

<p>As for parameters, <b><tt>s</tt></b> is the socket you're talking about,
level should be set to <b><tt>SOL_SOCKET</tt></b>.  Then you set the
<b><tt>optname</tt></b> to the name you're interested in.  Again, see your
man page for all the options, but here are some of the most fun
ones:</p>

<p><table cellpadding="10" cellspacing="0" border="0">

<tr><td valign="top" align="left" width="30%"><p><b><tt>SO_BINDTODEVICE</tt></b></p></td>

<td valign="top" align="left" width="68%"><p>Bind this socket to a symbolic device name like
<tt>eth0</tt> instead of using <tt>bind()</tt> to bind it to an IP
address.  Type the command <b><tt>ifconfig</tt></b> under Unix to see the
device names.</p></td>
</tr>


<tr><td valign="top" align="left"<p><b><tt>SO_REUSEADDR</tt></b></p></td>

<td valign="top" align="left"<p>Allows other sockets to <tt>bind()</tt> to this port, unless
there is an active listening socket bound to the port already.  This
enables you to get around those "Address already in use" error messages
when you try to restart your server after a crash.</p></td>
</tr>


<tr><td valign="top" align="left"<p><b><tt>SO_BROADCAST</tt></b></p></td>

<td valign="top" align="left"<p>Allows UDP datagram (<b><tt>SOCK_DGRAM</tt></b>) sockets to
send and recieve packets sent to and from the broadcast address.  Does
nothing--<i>NOTHING!!</i>--to TCP stream sockets!
Hahaha!</p></td>
</tr>


</table>
</p>

<p>As for the parameter <b><tt>optval</tt></b>, it's usually a pointer to an
<tt>int</tt> indicating the value in question.  For booleans, zero
is false, and non-zero is true.  And that's an absolute fact, unless
it's different on your system.  If there is no parameter to be passed,
<b><tt>optval</tt></b> can be <b><tt>NULL</tt></b>.</p>

<p>The final parameter, <b><tt>optlen</tt></b>, is filled out for you by
<tt>getsockopt()</tt> and you have to specify it for
<tt>getsockopt()</tt>, where it will probably be
<tt>sizeof(int)</tt>.</p>

<p><b>Warning</b>: on some systems (notably Sun and Windows), the option
can be a <tt>char</tt> instead of an <tt>int</tt>, and is set
to, for example, a character value of <tt>'1'</tt> instead of an
<tt>int</tt> value of <b><tt>1</tt></b>.  Again, check your own man
pages for more info with "<b><tt>man setsockopt</tt></b>" and "<b><tt>man 7
socket</tt></b>"!</p>

</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p>Returns zero on success, or <b><tt>-1</tt></b> on error (and
<tt>errno</tt> will be set accordingly.)</p>
</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int optval;
int optlen;
char *optval2;

// set SO_REUSEADDR on a socket to true (1):
optval = 1;
setsockopt(s1, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval));

// bind a socket to a device name (might not work on all systems):
optval2 = "eth1"; // 4 bytes long, so 4, below:
setsockopt(s2, SOL_SOCKET, SO_BINDTODEVICE, optval2, 4);

// see if the SO_BROADCAST flag is set:
getsockopt(s3, SOL_SOCKET, SO_BROADCAST, &amp;optval, &amp;optlen);
if (optval != 0) {
    print("SO_BROADCAST enabled on s3!\n");
}
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#fcntlman"><tt>fcntl()</tt></a></p>
</dd></dl>




<!--  ================================================================
== send(), sendto()
=================================================================  -->


<p><hr/>
<h2><a name="sendman"><tt>send()</tt>, <tt>sendto()</tt></a></h2></p>

<p>Send data out over a socket</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;sys/types.h&gt;</tt><br/>
<tt>#include &lt;sys/socket.h&gt;</tt></p>
<p><tt>ssize_t send(int s, const void *buf, size_t len,</tt><br/>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int flags);</tt></p>
<p><tt>ssize_t sendto(int s, const void *buf, size_t len,</tt><br/>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int flags, const struct sockaddr *to,</tt><br/>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socklen_t tolen);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>These functions send data to a socket.  Generally speaking,
<tt>send()</tt> is used for TCP <b><tt>SOCK_STREAM</tt></b> connected
sockets, and <tt>sendto()</tt> is used for UDP
<b><tt>SOCK_DGRAM</tt></b> unconnected datagram sockets.  With the
unconnected sockets, you must specify the destination of a packet each
time you send one, and that's why the last parameters of
<tt>sendto()</tt> define where the packet is going.</p>

<p>With both <tt>send()</tt> and <tt>sendto()</tt>, the
parameter <b><tt>s</tt></b> is the socket, <b><tt>buf</tt></b> is a pointer to the
data you want to send, <b><tt>len</tt></b> is the number of bytes you want to
send, and <b><tt>flags</tt></b> allows you to specify more information about
how the data is to be sent.  Set <b><tt>flags</tt></b> to zero if you want it
to be "normal" data.  Here are some of the commonly used flags, but
check your local <tt>send()</tt> man pages for more details:</p>

<p><table cellpadding="10" cellspacing="0" border="0">

<tr><td valign="top" align="left" width="30%"><p><b><tt>MSG_OOB</tt></b></p></td>

<td valign="top" align="left" width="68%"><p>Send as "out of band" data.  TCP supports this, and
it's a way to tell the receiving system that this data has a higher
priority than the normal data.  The receiver will recieve the signal
<b><tt>SIGURG</tt></b> and it can then recieve this data without first
recieving all the rest of the normal data in the queue.</p></td>
</tr>


<tr><td valign="top" align="left" width="30%"><p><b><tt>MSG_DONTROUTE</tt></b></p></td>

<td valign="top" align="left" width="68%"><p>Don't send this data over a router, just keep it
local.</p></td>
</tr>


<tr><td valign="top" align="left" width="30%"><p><b><tt>MSG_DONTWAIT</tt></b></p></td>

<td valign="top" align="left" width="68%"><p>If <tt>send()</tt> would block because outbound
traffic is clogged, have it return <b><tt>EAGAIN</tt></b>.  This is like
a "enable non-blocking just for this send."  See the section on <a href="#blocking">blocking</a>  for more details.</p></td>
</tr>


<tr><td valign="top" align="left" width="30%"><p><b><tt>MSG_NOSIGNAL</tt></b></p></td>

<td valign="top" align="left" width="68%"><p>If you <tt>send()</tt> to a remote host which is
no longer <tt>recv()</tt>ing, you'll typically get the signal
<b><tt>SIGPIPE</tt></b>.  Adding this flag prevents that signal from
being raised.</p></td>
</tr>


</table>
</p>

</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p>Returns the number of bytes actually sent, or <b><tt>-1</tt></b> on
error (and <tt>errno</tt> will be set accordingly.)  Note that the
number of bytes actually sent might be less than the number you asked it
to send!  See the section on <a href="#sendall">handling partial
<tt>send()</tt>s</a> for a helper function to get around this.</p>

<p>Also, if the socket has been closed by either side, the process
calling <tt>send()</tt> will get the signal <b><tt>SIGPIPE</tt></b>.
(Unless <tt>send()</tt> was called with the
<b><tt>MSG_NOSIGNAL</tt></b> flag.)</p>
</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int spatula_count = 3490;
char *secret_message = "The Cheese is in The Toaster";

int stream_socket, dgram_socket;
struct sockaddr_in dest;
int temp;

// first with TCP stream sockets:
stream_socket = socket(PF_INET, SOCK_STREAM, 0);
.
.
.
// convert to network byte order
temp = htonl(spatula_count);
// send data normally:
send(stream_socket, &amp;temp, sizeof(temp), 0);

// send secret message out of band:
send(stream_socket, secret_message, strlen(secret_message)+1, MSG_OOB);

// now with UDP datagram sockets:
dgram_socket = socket(PF_INET, SOCK_DGRAM, 0);
.
.
.
// build destination
dest.sin_family = AF_INET;
inet_aton("10.0.0.1", &amp;dest.sin_addr);
dest.sin_port = htons(2223);

// send secret message normally:
sendto(dgram_socket, secret_message, strlen(secret_message)+1, 0, 
       (struct sockaddr*)&amp;dest, sizeof(dest));
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#recvman"><tt>recv()</tt></a>,
<a href="#recvman"><tt>recvfrom()</tt></a></p>
</dd></dl>




<!--  ================================================================
== shutdown()
=================================================================  -->


<p><hr/>
<h2><a name="shutdownman"><tt>shutdown()</tt></a></h2></p>

<p>Stop further sends and recieves on a socket</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;sys/socket.h&gt;</tt></p>
<p><tt>int shutdown(int s, int how);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>That's it!  I've had it!  No more <tt>send()</tt>s are allowed on
this socket, but I still want to <tt>recv()</tt> data on it!  Or
vice-versa!  How can I do this?</p>

<p>When you <tt>close()</tt> a socket descriptor, it closes both
sides of the socket for reading and writing, and frees the socket
descriptor.  If you just want to close one side or the other, you can
use this <tt>shutdown()</tt> call.</p>

<p>As for parameters, <b><tt>s</tt></b> is obviously the socket you want to
perform this action on, and what action that is can be specified with
the <b><tt>how</tt></b> paramter.  How can be <b><tt>SHUT_RD</tt></b> to
prevent further <tt>recv()</tt>s, <b><tt>SHUT_WR</tt></b> to prohibit
further <tt>send()</tt>s, or <b><tt>SHUT_RDWR</tt></b> to do
both.</p>

<p>Note that <tt>shutdown()</tt> doesn't free up the socket
descriptor, so you still have to eventually <tt>close()</tt> the
socket even if it has been fully shut down.</p>

<p>This is a rarely used system call.</p>
</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p>Returns zero on success, or <b><tt>-1</tt></b> on error (and
<tt>errno</tt> will be set accordingly.)</p>
</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int s = socket(PF_INET, SOCK_STREAM, 0);

// ...do some send()s and stuff in here...

// and now that we're done, don't allow any more sends()s:
shutdown(s, SHUT_RD);
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#closeman"><tt>close()</tt></a></p>
</dd></dl>




<!--  ================================================================
== socket()
=================================================================  -->


<p><hr/>
<h2><a name="socketman"><tt>socket()</tt></a></h2></p>

<p>Allocate a socket descriptor</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><tt>#include &lt;sys/types.h&gt;</tt><br/>
<tt>#include &lt;sys/socket.h&gt;</tt></p>
<p><tt>int socket(int domain, int type, int protocol);</tt></p>
</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>
<p>Returns a new socket descriptor that you can use to do sockety things
with.  This is generally the first call in the whopping process of
writing a socket program, and you can use the result for subsequent
calls to <tt>listen()</tt>, <tt>bind()</tt>, <tt>accept()</tt>, or a
variety of other functions.</p>

<p>
<table cellpadding="10" cellspacing="0" border="0">

<tr><td valign="top" align="left" width="20%"><p><b><tt>domain</tt></b></p></td>


<td valign="top" align="left" width="78%"><p><b><tt>domain</tt></b> describes what kind of socket
you're interested in.  This can, believe me, be a wide variety of
things, but since this is a socket guide, it's going to be
<b><tt>PF_INET</tt></b> for you.  And, correspondingly, when you load up
your <tt>struct sockaddr_in</tt> to use with this socket, you're
going to set the <tt>sin_family</tt> field to
<b><tt>AF_INET</tt></b></p>

<p>(Also of interest is <b><tt>PF_INET6</tt></b> if you're going to be
doing IPv6 stuff.  If you don't know what that is, don't worry about
it...yet.)</p></td>
</tr>


<tr><td valign="top" align="left"<p><b><tt>type</tt></b></p></td>


<td valign="top" align="left"<p>Also, the <b><tt>type</tt></b> parameter can be a number of things, but
you'll probably be setting it to either <b><tt>SOCK_STREAM</tt></b> for
reliable TCP sockets (<tt>send()</tt>, <tt>recv()</tt>) or
<b><tt>SOCK_DGRAM</tt></b> for unreliable fast UDP sockets
(<tt>sendto()</tt>, <tt>recvfrom()</tt>.)</p>

<p>(Another interesting socket type is <b><tt>SOCK_RAW</tt></b> which can
be used to construct packets by hand.  It's pretty cool.)</p></td>
</tr>


<tr><td valign="top" align="left"<p><b><tt>protocol</tt></b></p></td>


<td valign="top" align="left"<p>Finally, the <b><tt>protocol</tt></b> parameter tells which protocol to
use with a certain socket type.  Like I've already said, for instance,
<b><tt>SOCK_STREAM</tt></b> uses TCP.  Fortunately for you, when using
<b><tt>SOCK_STREAM</tt></b> or <b><tt>SOCK_DGRAM</tt></b>, you can just
set the protocol to 0, and it'll use the proper protocol automatically.
Otherwise, you can use <tt>getprotobyname()</tt> to look up the
proper protocol number.</p></td>


</tr>
</table>
</p>

</dd></dl>

<dl><dt><b>Return Value</b></dt>
<dd>
<p>The new socket descriptor to be used in subsequent calls, or
<b><tt>-1</tt></b> on error (and <tt>errno</tt> will be set
accordingly.)</p>
</dd></dl>


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
int s1, s2;

s1 = socket(PF_INET, SOCK_STREAM, 0);
s2 = socket(PF_INET, SOCK_DGRAM, 0);

if (s1 == -1) {
    perror("socket");
}
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#acceptman"><tt>accept()</tt></a>,
<a href="#bindman"><tt>bind()</tt></a>,
<a href="#listenman"><tt>listen()</tt></a></p>
</dd></dl>




<!--  ================================================================
== sockaddr_in, in_addr
=================================================================  -->


<p><hr/>
<h2><a name="sockaddr_inman"><tt>struct sockaddr_in</tt>, <tt>struct in_addr</tt></a></h2></p>

<p>Structures for handling internet addresses</p>

<dl><dt><b>Prototypes</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
#include &lt;netinet/in.h&gt;

struct sockaddr_in {
    short            sin_family;   // e.g. AF_INET
    unsigned short   sin_port;     // e.g. htons(3490)
    struct in_addr   sin_addr;     // see struct in_addr, below
    char             sin_zero[8];  // zero this if you want to
};

struct in_addr {
    unsigned long s_addr;  // load with inet_aton()
};
</pre>
</table></p>

</dd></dl>


<dl><dt><b>Description</b></dt>
<dd>

<p>These are the basic structures for all syscalls and functions that
deal with internet addresses.  In memory, the <tt>struct
sockaddr_in</tt> is the same size as <tt>struct sockaddr</tt>, and
you can freely cast the pointer of one type to the other without any
harm, except the possible end of the universe.</p>

<p>Just kidding on that end-of-the-universe thing...if the universe does
end when you cast a <tt>struct sockaddr_in*</tt> to a <tt> struct
sockaddr*</tt>, I promise you it's pure coincidence and you shouldn't
even worry about it.</p>

<p>So, with that in mind, remember that whenever a function says it
takes a <tt>struct sockaddr*</tt> you can cast your <tt>struct
sockaddr_in*</tt> to that type with ease and safety.</p>

<p>There's also this <tt>sin_zero</tt> field which some people claim
must be set to zero.  Other people don't claim anything about it (the
Linux documentation doesn't even mention it at all), and setting it to
zero doesn't seem to be actually necessary.  So, if you feel like it,
set it to zero using <tt>memset()</tt>.</p>

<p>Now, that <tt>struct in_addr</tt> is a weird beast on different
systems.  Sometimes it's a crazy <tt>union</tt> with all kinds of
<tt>#define</tt>s and other nonsense.  But what you should do is only
use the <b><tt>s_addr</tt></b> field in this structure, because many systems
only implement that one.</p>

<p>With IPv4 (what basically everyone in 2005 still uses), the
<tt>struct s_addr</tt> is a 4-byte number that represents one digit
in an IP address per byte.  (You won't ever see an IP address with a
number in it greater than 255.)</p>

</dd></dl>

<!-- 
<rvalue>
</rvalue>
 -->


<dl><dt><b>Example</b></dt>
<dd>
<p><table border="0" cellpadding="10" cellspacing="0">
<tr><td bgcolor="#cfcfcf">
<pre>
struct sockaddr_in myaddr;
int s;

myaddr.sin_family = AF_INET;
myaddr.sin_port = htons(3490);
inet_aton("63.161.169.137", &amp;myaddr.sin_addr.s_addr);

s = socket(PF_INET, SOCK_STREAM, 0);
bind(s, (struct sockaddr*)myaddr, sizeof(myaddr));
</pre>
</table></p>

</dd></dl>


<dl><dt><b>See Also</b></dt>
<dd>
<p><a href="#acceptman"><tt>accept()</tt></a>,
<a href="#bindman"><tt>bind()</tt></a>,
<a href="#connectman"><tt>connect()</tt></a>,
<a href="#inet_ntoaman"><tt>inet_aton()</tt></a>,
<a href="#inet_ntoaman"><tt>inet_ntoa()</tt></a></p>
</dd></dl>






<!--  ================================================================
== manpage header
=================================================================  -->

<!--  <manpage id="">
<title><func></func></title>
<short><p></p></short>

<prototypes>
<p><tt>#include &lt;sys/.h&gt;</tt><br/>
<tt>#include &lt;sys/.h&gt;</tt></p>
<p><tt></tt><br/>
<tt></tt></p>
</prototypes>

<description>
</description>

<rvalue>
<p>Returns zero on success, or <const>-1</const> on error (and
<func>errno</func> will be set accordingly.)</p>
</rvalue>

<example>
<code>
</code>
</example>

<seealso>
<p><link dest="socketman"><func>socket()</func></link>,
<link dest="shutdownman"><func>shutdown()</func></link></p>
</seealso>

</manpage>  -->



<!--  =======================================================  -->

<!--  reference  -->

<!--  =======================================================  -->




<p><br/><hr/><h2>9. <a name="reference">More References</a></h2></p>


<p>You've come this far, and now you're screaming for more!  Where
else can you go to learn more about all this stuff?</p>

<!--  =======================================================  -->

<!--  books  -->

<!--  =======================================================  -->




<p><br/><h3>9.1. <a name="books">Books</a></h3></p>


<p>For old-school actual hold-it-in-your-hand pulp paper books, try
some of the following excellent guides.  Note the prominent Amazon.com
logo.  What all this shameless commercialism means is that I basically
get a kickback (Amazon.com store credit, actually) for selling these
books through this guide.  So if you're going to order one of these
books anyway, why not send me a special thank you by starting your spree
from one of the links, below.</p>

<p>Besides, more books for me might ultimately lead to more guides
for you. <tt>;-)</tt></p>

<p>
<a href="http://www.amazon.com/exec/obidos/redirect-home/beejsguides-20">
<img src="home-logo-130x60w.png" alt="None"/>

</a>
</p>

<p><i>Unix Network Programming, volumes 1-2</i> by W.
Richard Stevens.  Published by Prentice Hall.
ISBNs for volumes 1-2:
<a href="http://www.amazon.com/exec/obidos/ASIN/013490012X/beejsguides-20">013490012X</a>,
<a href="http://www.amazon.com/exec/obidos/ASIN/0130810819/beejsguides-20">0130810819</a>.
</p>

<p><i>Internetworking with TCP/IP, volumes I-III</i> by
Douglas E. Comer and David L. Stevens.  Published by Prentice Hall.
ISBNs for volumes I, II, and III:
<a href="http://www.amazon.com/exec/obidos/ASIN/0130183806/beejsguides-20">0130183806</a>,
<a href="http://www.amazon.com/exec/obidos/ASIN/0139738436/beejsguides-20">0139738436</a>,
<a href="http://www.amazon.com/exec/obidos/ASIN/0138487146/beejsguides-20">0138487146</a>.
</p>

<p><i>TCP/IP Illustrated, volumes 1-3</i> by W. Richard
Stevens and Gary R. Wright.  Published by Addison Wesley.
ISBNs for volumes 1, 2, and 3:
<a href="http://www.amazon.com/exec/obidos/ASIN/0201633469/beejsguides-20">0201633469</a>,
<a href="http://www.amazon.com/exec/obidos/ASIN/020163354X/beejsguides-20">020163354X</a>,
<a href="http://www.amazon.com/exec/obidos/ASIN/0201634953/beejsguides-20">0201634953</a>.
</p>

<p><i>TCP/IP Network Administration</i> by Craig Hunt.
Published by O'Reilly &amp; Associates, Inc.
ISBN
<a href="http://www.amazon.com/exec/obidos/ASIN/1565923227/beejsguides-20">1565923227</a>.
</p>

<p><i>Advanced Programming in the UNIX Environment</i>
by W. Richard Stevens.  Published by Addison Wesley.
ISBN
<a href="http://www.amazon.com/exec/obidos/ASIN/0201563177/beejsguides-20">0201563177</a>.
</p>

<p><i>Using C on the UNIX System</i> by David A. Curry.
Published by O'Reilly &amp; Associates, Inc.  ISBN 0937175234.
<i>Out of print.</i></p>



<!--  =======================================================  -->

<!--  webref  -->

<!--  =======================================================  -->




<p><br/><h3>9.2. <a name="webref">Web References</a></h3></p>


<p>On the web:</p>

<p><i><a href="http://www.cs.umn.edu/~bentlema/unix/"> BSD
Sockets: A Quick And Dirty Primer</a></i> (has other great
Unix system programming info, too!)</p>

<p><i><a href="http://www.developerweb.net/sock-faq/">The Unix
Socket FAQ</a></i></p>

<p><i><a href="http://pandonia.canberra.edu.au/ClientServer/">Client-Server
Computing</a></i></p>

<p><i><a href="http://pclt.cis.yale.edu/pclt/COMM/TCPIP.HTM">
Intro to TCP/IP</a></i></p>

<p><i><a href="http://www.doc.ic.ac.uk/~ih/doc/pc_conn/tcpip/intro/intro0.html">
Another Different Intro to TCP/IP</a></i></p>

<p><i><a href="http://www.faqs.org/faqs/internet/tcp-ip/tcp-ip-faq/part1/">TCP/IP
FAQ</a></i></p>

<p><i><a href="http://tangentsoft.net/wskfaq/">The Winsock
FAQ</a></i></p>



<!--  =======================================================  -->

<!--  rfcs  -->

<!--  =======================================================  -->




<p><br/><h3>9.3. <a name="rfcs">RFCs</a></h3></p>


<p><a href="http://www.rfc-editor.org/">RFCs</a>--the real dirt:</p>

<p><i><a href="http://www.rfc-editor.org/rfc/rfc768.txt">RFC-768</a></i>--The User
Datagram Protocol (UDP)</p>

<p><i><a href="http://www.rfc-editor.org/rfc/rfc791.txt">RFC-791</a></i>--The Internet
Protocol (IP)</p>

<p><i><a href="http://www.rfc-editor.org/rfc/rfc793.txt">RFC-793</a></i>--The Transmission
Control Protocol (TCP)</p>

<p><i><a href="http://www.rfc-editor.org/rfc/rfc854.txt">RFC-854</a></i>--The Telnet
Protocol</p>

<p><i><a href="http://www.rfc-editor.org/rfc/rfc951.txt">RFC-951</a></i>--The Bootstrap
Protocol (BOOTP)</p>

<p><i><a href="http://www.rfc-editor.org/rfc/rfc1350.txt">RFC-1350</a></i>--The Trivial
File Transfer Protocol (TFTP)</p>



 <!--  reference  -->



</body>
</html>
